{"componentChunkName":"component---src-templates-blog-post-js","path":"/2018-03-24--Scope-and-closure-(1):-lexical-scope/","result":{"data":{"site":{"siteMetadata":{"title":"Joel's dev blog","author":"Joel Mun","siteUrl":"https://9oelm.github.io"}},"markdownRemark":{"id":"11e8bd70-80c3-5dee-9379-5b3ac76ba5b7","excerpt":"FYI Notes made with You don’t know JS. Simplified steps in compilation Tokenizing: breaking the code into single parts, like  to  and  and  and . Parsing…","html":"<h2>FYI</h2>\n<p>Notes made with <a href=\"https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md\">You don’t know JS</a>.</p>\n<h3>Simplified steps in compilation</h3>\n<ol>\n<li>Tokenizing: breaking the code into single parts, like <code class=\"language-text\">var test = 2</code> to <code class=\"language-text\">var</code> and <code class=\"language-text\">test</code> and <code class=\"language-text\">=</code> and <code class=\"language-text\">2</code>.</li>\n<li>Parsing: “taking a stream (array) of tokens and turning it into <strong>a tree of nested elements</strong>, which collectively represent the grammatical structure of the program. This tree is called an “AST” (Abstract Syntax Tree).”</li>\n<li>Code generation: the process of taking an AST and turning it into executable code (machine readable)</li>\n<li>Note: Compilation happens really fast for javascript.</li>\n</ol>\n<h3>Explained</h3>\n<ol>\n<li>Compiler declares a variable (if not previously declared in the current scope)</li>\n<li>When executing, Engine looks up the variable in Scope and assigns to it, if found.</li>\n</ol>\n<h3>LHS and RHS (<em>more of non-LHS</em>) reference</h3>\n<ol>\n<li>LHS reference: <code class=\"language-text\">a</code> in <code class=\"language-text\">var a = 1</code>. **For assigning a value to a variable. **</li>\n<li>\n<p>RHS reference: **for referencing a value to a variable. **</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">hi</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">comment</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    window<span class=\"token punctuation\">.</span><span class=\"token function\">alert</span><span class=\"token punctuation\">(</span>comment<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">hi</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"hi\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<ul>\n<li>RHS function call to <code class=\"language-text\">hi()</code> function in the last line.</li>\n<li>LHS reference for <code class=\"language-text\">comment = &quot;hi&quot;</code></li>\n<li>RHS reference for <code class=\"language-text\">comment</code> in <code class=\"language-text\">window.alert(comment)</code>.</li>\n<li>RHS reference for <code class=\"language-text\">window</code>.</li>\n</ul>\n</li>\n</ol>\n<h3>Nested scope</h3>\n<ul>\n<li>Scopes can be nested inside other scopes. </li>\n<li>The javascript engine will look into <strong>the immediate scope first where the variable is referenced</strong>, and if it cannot find the variable, it will look at the outer scope, and then outer scope and so on (until the global scope).</li>\n<li>\n<p>if <strong>RHS look-up fails</strong>, it will cause a <code class=\"language-text\">ReferenceError</code>.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>this will cause an error since compiler does not know the variable <code class=\"language-text\">i</code> at all.</p>\n</li>\n<li>\n<p>if <strong>LHS look-up fails and the program is not in <code class=\"language-text\">strict</code> mode</strong>, the global scope will create a new variable of that name in the global scope. For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">i <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span>\nconsole<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>i<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// LHS lookup fails in the first line and the global scope will make a new variable called i.</span>\n<span class=\"token comment\">// in other words, it will do var i; for us. </span></code></pre></div>\n<p>this works perfectly fine without any errors in javascript.</p>\n</li>\n</ul>\n<h3>Two types of scope</h3>\n<ol>\n<li>Lexical scope (widely used)</li>\n<li>Dynamic scope</li>\n</ol>\n<h3>Lexical scope</h3>\n<ul>\n<li>\n<blockquote>\n<p>“The lexing process examines a string of source code characters and <strong>assigns semantic meaning to the tokens</strong> as a result of some stateful parsing.”</p>\n</blockquote>\n</li>\n<li>The lexical scope is defined at the lexing (write) time and is based on the scopes and variables that I write. </li>\n<li>\n<p><em><strong>Scope look-up stops once it finds the first match. The same identifier name can be specified at multiple layers of nested scope, which is called “shadowing”</strong></em> (the inner identifier “shadows” the outer identifier). Regardless of shadowing, scope look-up always starts at the innermost scope being executed at the time, and <strong>works its way outward/upward until the first match, and stops.</strong> My understanding is this:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> test <span class=\"token operator\">=</span> <span class=\"token number\">1</span><span class=\"token punctuation\">;</span> \n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// will log 1 because var test = 1 is in the current scope</span>\n    <span class=\"token keyword\">function</span> <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">var</span> test <span class=\"token operator\">=</span> <span class=\"token number\">2</span><span class=\"token punctuation\">;</span> \n        <span class=\"token comment\">// will log 2 because var test = 2 is in the current scope</span>\n        console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token keyword\">function</span> <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">var</span> test <span class=\"token operator\">=</span> <span class=\"token number\">3</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// will log 3 because var test = 3 is in the current scope</span>\n            console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span>\n        <span class=\"token function\">c</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token function\">b</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// a is executed here</span></code></pre></div>\n</li>\n<li>\n<p>But if you allege to have two variables of the same name that can be referenced at the same time, you could attach one to the global object as its property (FYI, Global variables are also automatically properties of the global object like <code class=\"language-text\">window</code>) . For example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\">window<span class=\"token punctuation\">.</span>test <span class=\"token operator\">=</span> <span class=\"token string\">\"another 0\"</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">var</span> test <span class=\"token operator\">=</span> <span class=\"token string\">\"0\"</span><span class=\"token punctuation\">;</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// logs 0</span>\n    console<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span>window<span class=\"token punctuation\">.</span>test<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// logs another 0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token comment\">// This is completely possible. </span></code></pre></div>\n</li>\n</ul>\n<h3>Other ways in Lexical scope</h3>\n<blockquote>\n<p>“Both of them are equally frowned-upon in the wider community as bad practices to use in your code. But the typical arguments against them are often missing the most important point: <strong>cheating lexical scope leads to poorer performance.</strong>”</p>\n</blockquote>\n<h3>1. <code class=\"language-text\">eval()</code></h3>\n<ul>\n<li>\n<p>The <code class=\"language-text\">eval(..)</code> function in JavaScript takes a string as an argument, and <strong>treats the contents of the string as if it had actually been authored code at that point in the program.</strong>\nFor example:</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">function</span> <span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">str</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">{</span>\n    <span class=\"token function\">eval</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token function\">console</span><span class=\"token punctuation\">(</span>b<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// will print 0</span>\n<span class=\"token punctuation\">}</span>\n<span class=\"token function\">a</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"b = 0\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n</li>\n<li>Note: <code class=\"language-text\">eval()</code> in <code class=\"language-text\">strict</code> mode is almost useless because “eval(..) when used in a strict-mode program operates in its own lexical scope, which means declarations made inside of the eval() do not actually modify the enclosing scope.”</li>\n<li>Note 2: this function is not really worth using because it does not add anything to the program most of the time. </li>\n</ul>\n<h3>2. <code class=\"language-text\">with()</code>: deprecated. So I’m not gonna study it.</h3>\n<h3><code class=\"language-text\">eval()</code> and <code class=\"language-text\">with()</code> are never good.</h3>\n<blockquote>\n<p>“The JavaScript Engine has a number of performance optimizations that it performs during the compilation phase. Some of these boil down to being able to essentially statically analyze the code as it lexes, and pre-determine where all the variable and function declarations are, so that it takes less effort to resolve identifiers during execution.”</p>\n</blockquote>\n<blockquote>\n<p>“But if the Engine finds an eval(..) or with in the code, <strong>it essentially has to assume that all its awareness of identifier location may be invalid, because it cannot know at lexing time exactly what code you may pass to eval(..) to modify the lexical scope, or the contents of the object you may pass to with to create a new lexical scope to be consulted.”</strong></p>\n</blockquote>\n<blockquote>\n<p>“In other words, in the pessimistic sense, <strong>most of those optimizations it would make are pointless if eval(..) or with are present, so it simply doesn’t perform the optimizations at all.</strong>”</p>\n</blockquote>","frontmatter":{"title":"Scope and closure (1): lexical Scope","date":"March 24, 2018"}}},"pageContext":{"slug":"/2018-03-24--Scope-and-closure-(1):-lexical-scope/","previous":{"fields":{"slug":"/2018-03-24--Scope-and-closure-(3):-hoisting/"},"frontmatter":{"title":"Scope and closure (3): hoisting"}},"next":{"fields":{"slug":"/2018-03-24--Scope-and-closure-(2):-writing-good-codes/"},"frontmatter":{"title":"Scope and closure (2): writing good codes"}}}},"staticQueryHashes":["3128451518","426816048"]}