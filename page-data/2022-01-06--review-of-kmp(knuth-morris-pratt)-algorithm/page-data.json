{"componentChunkName":"component---src-templates-blog-post-js","path":"/2022-01-06--review-of-kmp(knuth-morris-pratt)-algorithm/","result":{"data":{"site":{"siteMetadata":{"title":"Joel's dev blog","author":"Joel Mun","siteUrl":"https://9oelm.github.io"}},"markdownRemark":{"id":"f2a515ad-d10a-544b-960d-812246e56cbd","excerpt":"Find the shortest palindrome So I encountered this problem during my study: ‘shortest palindrome’. The problem reads: You are given a string s. You can convert…","html":"<h1 id=\"find-the-shortest-palindrome\" style=\"position:relative;\">Find the shortest palindrome<a href=\"#find-the-shortest-palindrome\" aria-label=\"find the shortest palindrome permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>So I encountered <a href=\"https://leetcode.com/problems/shortest-palindrome/\">this problem</a> during my study: ‘shortest palindrome’. The problem reads:</p>\n<blockquote>\n<p>You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: s = &quot;aacecaaa&quot;\nOutput: &quot;aaacecaaa&quot;\nExample 2:\n\nInput: s = &quot;abcd&quot;\nOutput: &quot;dcbabcd&quot;\n\nConstraints:\n\n0 &lt;= s.length &lt;= 5 * 104\ns consists of lowercase English letters only.</code></pre></div>\n<p>I tried to solve this problem with some naive algorithm, and it passed but almost failed on time and space complexity contraints. So I was wondering if there would be a specific algorithm that would solve this problem more efficiently.</p>\n<p>The gist of this solution lies in the point that we just need to <strong><em>find the longest palindrome substring from the beginning of the substring</em></strong>. If we find that palindrome substring, we can just add the reverse of the rest of the string to the front of it to get the shortest palindrome.</p>\n<p>For example, <code class=\"language-text\">aacecaaa</code> has the longest palindrome substring <code class=\"language-text\">aacecaa</code>. Therefore, the leftover is <code class=\"language-text\">a</code>, which can be appended to the front of the original string, which yields <code class=\"language-text\">aaacecaaa</code>.</p>\n<p>If we don’t use the longest palindrome substring, we can see that the answer will not be the shortest. For example, <code class=\"language-text\">aacecaaa</code> also has the palindrome substring <code class=\"language-text\">aa</code> at its beginning. Adding the reverse of the leftover to the beggining of the original string will yield <code class=\"language-text\">aaacecaacecaaa</code>, which is longer than the shortest palindrome we’ve found above. </p>\n<p>Now, how can we possibly find the longest palindrome substring from the beginning of the substring in an efficient way?</p>\n<h1 id=\"inefficient-algorithm-bruteforcing\" style=\"position:relative;\">Inefficient algorithm: bruteforcing<a href=\"#inefficient-algorithm-bruteforcing\" aria-label=\"inefficient algorithm bruteforcing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>when:</p>\n<ul>\n<li><code class=\"language-text\">n = length of the string to be matched</code></li>\n<li><code class=\"language-text\">m = length of the pattern to be matched</code></li>\n</ul>\n<p>Whenever we are naively doing some pattern matching task, there are inefficient steps that would make the algorithm at most <code class=\"language-text\">O(n*m)</code>. </p>\n<p>For example, let’s say that you are looking for every occurence of <code class=\"language-text\">abc</code> in <code class=\"language-text\">abceabcii</code>. This means <code class=\"language-text\">n = 3</code> and <code class=\"language-text\">m = 9</code>.</p>\n<p>Then, <a href=\"https://replit.com/@9oelM/matching-patterns-bruteforce?v=1\">the naive approach would be brute forcing</a> each character with the pattern:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">brute</span><span class=\"token punctuation\">(</span>s <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> pattern <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n\tn <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n\tm <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">var</span> matchingIndices <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span>\n\n\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> s <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> i<span class=\"token operator\">+</span>m <span class=\"token operator\">></span> n <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">break</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">if</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">:</span>i<span class=\"token operator\">+</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pattern <span class=\"token punctuation\">{</span>\n\t\t\tmatchingIndices <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>matchingIndices<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> matchingIndices\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tcases <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token string\">\"abceabciiabc\"</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> cases <span class=\"token punctuation\">{</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">brute</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<iframe frameborder=\"0\" width=\"100%\" height=\"300px\" src=\"https://replit.com/@9oelM/matching-patterns-bruteforce?embed=true\"></iframe>\n<p>The time complexity will be <code class=\"language-text\">O(n*m)</code> because we are iterating over the string <code class=\"language-text\">n</code> times and each time we are iterating over the pattern <code class=\"language-text\">m</code> times because <code class=\"language-text\">s[i:i+m] == pattern</code> will take at most <code class=\"language-text\">O(m)</code> times to complete, as it is checking string equality.</p>\n<p>Anyway, it is easy to spot the inefficiency. Let’s take a look at the algorithm step by step. First, we will try to match <code class=\"language-text\">abc</code> with <code class=\"language-text\">abc</code>, <code class=\"language-text\">bce</code> with <code class=\"language-text\">abc</code>, <code class=\"language-text\">cea</code> with <code class=\"language-text\">abc</code>, and then <code class=\"language-text\">eab</code> with <code class=\"language-text\">abc</code> and so on. But what we know for sure is that when you encounter <code class=\"language-text\">abc</code>, you already know that the next two words of length <code class=\"language-text\">m</code> will start with <code class=\"language-text\">b</code> and <code class=\"language-text\">c</code>, which are not the start of the characters we are looking for. So we can safely skip the <code class=\"language-text\">b</code> and <code class=\"language-text\">c</code>, and start fresh at <code class=\"language-text\">currentIndex+m</code>.</p>\n<p>Therefore, what’s important is how many characters you can safely skip. But exactly how many characters can you skip?</p>\n<h1 id=\"longest-proper-prefix-which-is-suffix-lps\" style=\"position:relative;\">Longest Proper Prefix which is Suffix (LPS)<a href=\"#longest-proper-prefix-which-is-suffix-lps\" aria-label=\"longest proper prefix which is suffix lps permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>To precisely find how many characters can be safely skipped, we need to find the longest proper prefix which is also a suffix. It <em>does sound weird</em>, but it is what it exactly reads.</p>\n<ul>\n<li>A proper prefix is any prefix of a word that is not the word itself.</li>\n<li>A suffix is any suffix of a word that is also the word itself.</li>\n</ul>\n<p>Let’s take the word <code class=\"language-text\">MOM</code> for example:</p>\n<ul>\n<li>Proper prefixes: <code class=\"language-text\">&#39;&#39;</code>, <code class=\"language-text\">&#39;M&#39;</code>, <code class=\"language-text\">&#39;MO&#39;</code></li>\n<li>Suffixes: <code class=\"language-text\">&#39;&#39;</code>, <code class=\"language-text\">&#39;M&#39;</code>, <code class=\"language-text\">&#39;OM&#39;</code>, <code class=\"language-text\">&#39;MOM&#39;</code></li>\n</ul>\n<p>Then, we can see that the LPS is <code class=\"language-text\">M</code>.</p>\n<p>The algorithm to find LPS is pretty simple. First, we will make an array (also called an auxiliary array) for storing the length of LPS in each unique prefix, like so:</p>\n<p>Given a string <code class=\"language-text\">ACABACACD</code>,</p>\n<ol>\n<li>check <code class=\"language-text\">A</code> is no LPS at all. record 0</li>\n<li>check <code class=\"language-text\">AC</code> has no LPS at all. record 0</li>\n<li>check <code class=\"language-text\">ACA</code> has an LPS of length 1 which is <code class=\"language-text\">A</code>. record <code class=\"language-text\">1</code></li>\n<li>check <code class=\"language-text\">ACAB</code> has no LPS at all. record 0</li>\n<li>check <code class=\"language-text\">ACABA</code> has an LPS of length 1 which is <code class=\"language-text\">A</code>. record <code class=\"language-text\">1</code></li>\n<li>check <code class=\"language-text\">ACABAC</code> has an LPS of length 2 which is <code class=\"language-text\">AC</code>. record <code class=\"language-text\">2</code></li>\n<li>check <code class=\"language-text\">ACABACA</code> has an LPS of length 3 which is <code class=\"language-text\">ACA</code>. record <code class=\"language-text\">3</code></li>\n<li>check <code class=\"language-text\">ACABACAC</code> has an LPS of length 2 which is <code class=\"language-text\">AC</code>, record <code class=\"language-text\">2</code></li>\n<li>check <code class=\"language-text\">ACABACACD</code> has no LPS at all. record 0</li>\n</ol>\n<p>The resulting LPS array should then be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 1, 0, 1, 2, 3, 2, 0]</code></pre></div>\n<h1 id=\"the-kmp-algorithm\" style=\"position:relative;\">The KMP algorithm<a href=\"#the-kmp-algorithm\" aria-label=\"the kmp algorithm permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>KMP is a string matching algorithm that runs in <code class=\"language-text\">O(n+m)</code> times, where</p>\n<ul>\n<li><code class=\"language-text\">n = length of the string to be matched</code></li>\n<li><code class=\"language-text\">m = length of the pattern to be matched</code></li>\n</ul>\n<p>This example runs with the following to elaborate the idea of KMP algorithm:</p>\n<ul>\n<li>text: <code class=\"language-text\">abcxabcdabxabcdabcdabcy</code></li>\n<li>pattern: <code class=\"language-text\">abcdabcy</code></li>\n</ul>\n<p>We realize that three characters (<code class=\"language-text\">abc</code>) match until we get to <code class=\"language-text\">text[3]</code> and <code class=\"language-text\">pattern[3]</code>. </p>\n<p>The aim is to <em>not go back to the previous indices</em> when we find this mismatch. We only want to go forward.</p>\n<p>Then we would need to find the LPS inside the <code class=\"language-text\">pattern</code> string right before <code class=\"language-text\">pattern[3]</code>: trivially, we know that <code class=\"language-text\">abc</code> does not have LPS inside itself because all characters are unique. </p>\n<p>This means we can start our next comparison directly from <code class=\"language-text\">text[3]</code> and <code class=\"language-text\">pattern[3]</code>, which are <code class=\"language-text\">x</code> and <code class=\"language-text\">a</code>.</p>\n<p>We compare <code class=\"language-text\">x</code> and <code class=\"language-text\">a</code> and they’re not a match, so we move to the next character. Forward on, we can see that <code class=\"language-text\">text[4:10]</code>, which is <code class=\"language-text\">abcdab</code>, has a exact match with <code class=\"language-text\">pattern[:6]</code>. But it’s not an entire match because <code class=\"language-text\">text[10]</code> and <code class=\"language-text\">pattern[6]</code> don’t match, which are <code class=\"language-text\">x</code> and <code class=\"language-text\">c</code>.</p>\n<p>Then we look for the LPS again in the substring of the pattern that had a match: <code class=\"language-text\">text[4:10]</code>, which is <code class=\"language-text\">abcdab</code>. Easily we can find that <code class=\"language-text\">ab</code> is an LPS at <code class=\"language-text\">pattern[0:2]</code> and <code class=\"language-text\">pattern[4:6]</code>. Having such an LPS means that the characters before <code class=\"language-text\">text[10]</code>, which is <code class=\"language-text\">x</code>, must be <code class=\"language-text\">ab</code>, trivially. But what this also means is that because <code class=\"language-text\">ab</code> is also a prefix of <code class=\"language-text\">abcdab</code>, we can start our next search from <code class=\"language-text\">text[10]</code> (<code class=\"language-text\">x</code>) and <code class=\"language-text\">pattern[2]</code> (<code class=\"language-text\">c</code>).</p>\n<p>Why? The search always consists of trivial character-by-character match, and the aim is to skip the redundant searches. <code class=\"language-text\">abcdab</code> of <code class=\"language-text\">abcdabcy</code> has an LPS as <code class=\"language-text\">ab</code> and the text we were matching has <code class=\"language-text\">... abcdabx ...</code>. This means that by the time we get to <code class=\"language-text\">x</code>, we already know that we don’t have to go back to the beginning of the pattern to start the search over, because we have already matched <code class=\"language-text\">ab</code>. Therefore, the next search will start from <code class=\"language-text\">x</code> and <code class=\"language-text\">pattern[2]</code>, which is <code class=\"language-text\">c</code>.</p>\n<p>Again, comparing <code class=\"language-text\">c</code> and <code class=\"language-text\">x</code>. Check if <code class=\"language-text\">pattern[0:2]</code> has an LPS: no. Then we start character matching from <code class=\"language-text\">x</code> and <code class=\"language-text\">pattern[0]</code>, all fresh again.</p>\n<p>Next up, we see that <code class=\"language-text\">... xabcdabcdabcy ...</code> has a match of <code class=\"language-text\">abcdabc</code> with <code class=\"language-text\">pattern[:7]</code>, but it’s not an entire match, leaving <code class=\"language-text\">y</code> in the last index in the pattern unmatched with <code class=\"language-text\">d</code> (<code class=\"language-text\">text[18]</code>). Again, we see if there is an LPS in <code class=\"language-text\">abcdabc</code>. This time, the LPS is <code class=\"language-text\">abc</code>. <em>This means that the last three characters that were checked for match are also the three characters at the beginning of the match, so we can safely say that we already have matched the last three characters (<code class=\"language-text\">abc</code>) in <code class=\"language-text\">... xabcdabcdabc ...</code> with the three first characters of the pattern (<code class=\"language-text\">abc</code>).</em> So we can start pattern matching from the next character: <code class=\"language-text\">d</code> (<code class=\"language-text\">text[18]</code>) and <code class=\"language-text\">pattern[4]</code>, which is also <code class=\"language-text\">d</code>. </p>\n<p>Then finally we find the substring <code class=\"language-text\">abcdabcy</code> at the end of the text with trivial character-by-character comparison.</p>\n<h1 id=\"finding-the-lps-the-efficient-way\" style=\"position:relative;\">Finding the LPS: the efficient way<a href=\"#finding-the-lps-the-efficient-way\" aria-label=\"finding the lps the efficient way permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>We know how KMP algorithm works, but we didn’t discuss what an efficient way of obtaining an LPS would be when we looked at how to find an LPS. This is how it’s done:</p>\n<ol>\n<li>Create <code class=\"language-text\">int</code> variables <code class=\"language-text\">j</code> and <code class=\"language-text\">i</code> to track indices of an <code class=\"language-text\">lps_array</code> of length <code class=\"language-text\">len(word)</code></li>\n<li>Let <code class=\"language-text\">j</code> track the prefix, and let <code class=\"language-text\">i</code> track the suffix of each substring.</li>\n<li>Let <code class=\"language-text\">j</code> and <code class=\"language-text\">i</code> all start from index <code class=\"language-text\">0</code>. But because index <code class=\"language-text\">0</code> is always not an LPS, just start <code class=\"language-text\">i</code> from index 1.</li>\n<li>Check if <code class=\"language-text\">word[j] == word[i]</code>. If <code class=\"language-text\">true</code>, <code class=\"language-text\">lps_array[i] = j + 1</code> (which is <code class=\"language-text\">the length of matching suffix = the index of previously matching prefix + 1</code>) and increment <code class=\"language-text\">j</code> and <code class=\"language-text\">i</code> by <code class=\"language-text\">1</code>. Otherwise, increment <code class=\"language-text\">i</code> and reset <code class=\"language-text\">j</code> to <code class=\"language-text\">lps_array[j - 1]</code> (which is <code class=\"language-text\">the length of previously matching prefix</code>). Start this step again.</li>\n</ol>\n<p>This Youtube video just kills it, so I’ve watched it multiple times. I’ve set it to start from the LPS part.</p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube-nocookie.com/embed/GTJr8OvyEVQ?start=495\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>For example, for a string: <code class=\"language-text\">aabaabaaa</code>, an LPS can be constructed with the following steps:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">createLpsArray</span><span class=\"token punctuation\">(</span>word <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    wordLen <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">var</span> lpsArray <span class=\"token punctuation\">[</span>wordLen<span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span>\n\n    i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n    j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;</span> wordLen <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n            lpsArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            <span class=\"token operator\">++</span>j\n            <span class=\"token operator\">++</span>i\n        <span class=\"token comment\">// has a prefix longer than 0 already, so check backwards again</span>\n        <span class=\"token comment\">// when there is a mismatch,</span>\n        <span class=\"token comment\">// we will check the index of previous</span>\n        <span class=\"token comment\">// possible prefix.</span>\n        <span class=\"token comment\">// this is possible because every element in the lps array</span>\n        <span class=\"token comment\">// represents the number of LPS in the substring from </span>\n        <span class=\"token comment\">// the beginning of the string to the index of the element.</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            j <span class=\"token operator\">=</span> lpsArray<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token comment\">// this means word[j] != word[i] &amp;&amp; j == 0</span>\n        <span class=\"token comment\">// there has been no prefix found so far for the current index i, so just move onto the next</span>\n        <span class=\"token comment\">// character to find the match</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token operator\">++</span>i\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> lpsArray\n<span class=\"token punctuation\">}</span></code></pre></div>\n<iframe frameborder=\"0\" width=\"100%\" height=\"300px\" src=\"https://replit.com/@9oelM/createLpsArray?embed=true\"></iframe>\n<p>The complexities, where <code class=\"language-text\">n</code> is the length of the word, are as follows:</p>\n<ul>\n<li>Time complexity: <code class=\"language-text\">O(n)</code></li>\n<li>Space complexity: <code class=\"language-text\">O(n)</code> because <code class=\"language-text\">lpsArray</code> is <code class=\"language-text\">[n]int</code>.</li>\n</ul>\n<h1 id=\"summing-everything-up-together-for-kmp-substring-search\" style=\"position:relative;\">Summing everything up together for KMP substring search<a href=\"#summing-everything-up-together-for-kmp-substring-search\" aria-label=\"summing everything up together for kmp substring search permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>Problem: given <code class=\"language-text\">a b x a b c a b c a b y</code> (spaces used for convenience), check if the text contains the pattern <code class=\"language-text\">a b c a b y</code>.</p>\n<h2 id=\"get-the-lps-array\" style=\"position:relative;\">Get the LPS array<a href=\"#get-the-lps-array\" aria-label=\"get the lps array permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p><code class=\"language-text\">a b c a b y</code>:</p>\n<ol>\n<li>\n<p><code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> are not the same, so the array would be</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 0, 0, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">a</code> and <code class=\"language-text\">c</code> are not the same, so the array will still be</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 0, 0, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">a</code> and <code class=\"language-text\">a</code> are the same. Increment <code class=\"language-text\">i</code> and <code class=\"language-text\">j</code> together by one.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 1, 0, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">b</code> and <code class=\"language-text\">b</code> are the same. Because <code class=\"language-text\">lpsArray[i] = lpsArray[j] + 1</code>, <code class=\"language-text\">lpsArray[i] = 1 + 1 = 2</code>. Increment <code class=\"language-text\">i</code> and <code class=\"language-text\">j</code> together by one.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 1, 2, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">c</code> and <code class=\"language-text\">y</code> are not the same. Then, look backwards (<code class=\"language-text\">j = lpsArray[j - 1]</code>) to see if there is any other prefixes available. <code class=\"language-text\">j = lpsArray[j - 1] = 0</code>. Again, <code class=\"language-text\">word[0] = a</code> and <code class=\"language-text\">a != y</code>. Mark <code class=\"language-text\">0</code> for the last index:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 1, 2, 0]</code></pre></div>\n</li>\n</ol>\n<p>Where:</p>\n<ul>\n<li><code class=\"language-text\">n = length of the string to be matched</code></li>\n<li><code class=\"language-text\">m = length of the pattern to be matched</code></li>\n</ul>\n<p>The time complexity to build the LPS array is <code class=\"language-text\">O(m)</code>, and that to find the substring from the text is <code class=\"language-text\">O(n)</code>. Therefore, adding them up together yields <code class=\"language-text\">O(m + n)</code>, which is the time complexity of the KMP substring search.</p>\n<h1 id=\"references\" style=\"position:relative;\">References<a href=\"#references\" aria-label=\"references permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li><a href=\"https://binary-baba.medium.com/string-matching-kmp-algorithm-27c182efa387\">https://binary-baba.medium.com/string-matching-kmp-algorithm-27c182efa387</a></li>\n<li><a href=\"https://towardsdatascience.com/pattern-search-with-the-knuth-morris-pratt-kmp-algorithm-8562407dba5b\">https://towardsdatascience.com/pattern-search-with-the-knuth-morris-pratt-kmp-algorithm-8562407dba5b</a></li>\n<li><a href=\"https://leetcode.com/problems/shortest-palindrome/solution/\">https://leetcode.com/problems/shortest-palindrome/solution/</a></li>\n<li><a href=\"https://youtu.be/GTJr8OvyEVQ\">https://youtu.be/GTJr8OvyEVQ</a></li>\n</ul>","frontmatter":{"title":"Review of KMP(Knuth–Morris–Pratt) algorithm","date":"January 06, 2022"}}},"pageContext":{"slug":"/2022-01-06--review-of-kmp(knuth-morris-pratt)-algorithm/","previous":{"fields":{"slug":"/2022-01-02--elasticpwn-how-to-find-and-collect-data-from-exposed-elasticsearch-and-kibana-instances/"},"frontmatter":{"title":"elasticpwn: how to collect and analyse data from exposed Elasticsearch and Kibana instances","tab":"post"}},"next":null}},"staticQueryHashes":["3128451518","426816048"]}