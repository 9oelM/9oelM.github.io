{"componentChunkName":"component---src-templates-blog-post-js","path":"/2022-01-06--find-the-shortest-palindrome-review-of-kmp(knuth-morris-pratt)-algorithm/","result":{"data":{"site":{"siteMetadata":{"title":"Joel's dev blog","author":"Joel Mun","siteUrl":"https://9oelm.github.io"}},"markdownRemark":{"id":"35e2e1b0-974a-5c2a-b099-3862533e9bc1","excerpt":"Find the shortest palindrome So I encountered this problem during my study: ‘shortest palindrome’. The problem reads: You are given a string s. You can convert…","html":"<h1 id=\"find-the-shortest-palindrome\" style=\"position:relative;\">Find the shortest palindrome<a href=\"#find-the-shortest-palindrome\" aria-label=\"find the shortest palindrome permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>So I encountered <a href=\"https://leetcode.com/problems/shortest-palindrome/\">this problem</a> during my study: ‘shortest palindrome’. The problem reads:</p>\n<blockquote>\n<p>You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: s = &quot;aacecaaa&quot;\nOutput: &quot;aaacecaaa&quot;\nExample 2:\n\nInput: s = &quot;abcd&quot;\nOutput: &quot;dcbabcd&quot;\n\nConstraints:\n\n0 &lt;= s.length &lt;= 5 * 104\ns consists of lowercase English letters only.</code></pre></div>\n<p>I tried to solve this problem with some naive algorithm, and it passed but almost failed on time and space complexity contraints. So I was wondering if there would be a specific algorithm that would solve this problem more efficiently.</p>\n<p>The gist of this solution lies in the point that we just need to <strong><em>find the longest palindrome substring from the beginning of the substring</em></strong>. If we find that palindrome substring, we can just add the reverse of the rest of the string to the front of it to get the shortest palindrome.</p>\n<p>For example, <code class=\"language-text\">aacecaaa</code> has the longest palindrome substring <code class=\"language-text\">aacecaa</code>. Therefore, the leftover is <code class=\"language-text\">a</code>, which can be appended to the front of the original string, which yields <code class=\"language-text\">aaacecaaa</code>.</p>\n<p>If we don’t use the longest palindrome substring, we can see that the answer will not be the shortest. For example, <code class=\"language-text\">aacecaaa</code> also has the palindrome substring <code class=\"language-text\">aa</code> at its beginning. Adding the reverse of the leftover to the beggining of the original string will yield <code class=\"language-text\">aaacecaacecaaa</code>, which is longer than the shortest palindrome we’ve found above. </p>\n<p>Now, how can we possibly find the longest palindrome substring from the beginning of the substring in an efficient way?</p>\n<h1 id=\"inefficient-algorithm-bruteforcing\" style=\"position:relative;\">Inefficient algorithm: bruteforcing<a href=\"#inefficient-algorithm-bruteforcing\" aria-label=\"inefficient algorithm bruteforcing permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>when:</p>\n<ul>\n<li><code class=\"language-text\">n = length of the string to be matched</code></li>\n<li><code class=\"language-text\">m = length of the pattern to be matched</code></li>\n</ul>\n<p>Whenever we are naively doing some pattern matching task, there are inefficient steps that would make the algorithm at most <code class=\"language-text\">O(n*m)</code>. </p>\n<p>For example, let’s say that you are looking for every occurence of <code class=\"language-text\">abc</code> in <code class=\"language-text\">abceabcii</code>. This means <code class=\"language-text\">n = 3</code> and <code class=\"language-text\">m = 9</code>.</p>\n<p>Then, <a href=\"https://replit.com/@9oelM/matching-patterns-bruteforce?v=1\">the naive approach would be brute forcing</a> each character with the pattern:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">brute</span><span class=\"token punctuation\">(</span>s <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> pattern <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n\tn <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n\tm <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span>\n\t<span class=\"token keyword\">var</span> matchingIndices <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span>\n\n\t<span class=\"token keyword\">for</span> i <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> s <span class=\"token punctuation\">{</span>\n\t\t<span class=\"token keyword\">if</span> i<span class=\"token operator\">+</span>m <span class=\"token operator\">></span> n <span class=\"token punctuation\">{</span>\n\t\t\t<span class=\"token keyword\">break</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t\t<span class=\"token keyword\">if</span> s<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">:</span>i<span class=\"token operator\">+</span>m<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pattern <span class=\"token punctuation\">{</span>\n\t\t\tmatchingIndices <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>matchingIndices<span class=\"token punctuation\">,</span> i<span class=\"token punctuation\">)</span>\n\t\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token punctuation\">}</span>\n\n\t<span class=\"token keyword\">return</span> matchingIndices\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\tcases <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n\t\t<span class=\"token string\">\"abceabciiabc\"</span><span class=\"token punctuation\">,</span>\n\t<span class=\"token punctuation\">}</span>\n\t<span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span> cases <span class=\"token punctuation\">{</span>\n\t\tfmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">brute</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">,</span> <span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n\t<span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<iframe frameborder=\"0\" width=\"100%\" height=\"800px\" src=\"https://replit.com/@9oelM/matching-patterns-bruteforce?lite=true\"></iframe>\n<p>The time complexity will be <code class=\"language-text\">O(n*m)</code> because we are iterating over the string <code class=\"language-text\">n</code> times and each time we are iterating over the pattern <code class=\"language-text\">m</code> times because <code class=\"language-text\">s[i:i+m] == pattern</code> will take at most <code class=\"language-text\">O(m)</code> times to complete, as it is checking string equality.</p>\n<p>Anyway, it is easy to spot the inefficiency. Let’s take a look at the algorithm step by step. First, we will try to match <code class=\"language-text\">abc</code> with <code class=\"language-text\">abc</code>, <code class=\"language-text\">bce</code> with <code class=\"language-text\">abc</code>, <code class=\"language-text\">cea</code> with <code class=\"language-text\">abc</code>, and then <code class=\"language-text\">eab</code> with <code class=\"language-text\">abc</code> and so on. But what we know for sure is that when you encounter <code class=\"language-text\">abc</code>, you already know that the next two words of length <code class=\"language-text\">m</code> will start with <code class=\"language-text\">b</code> and <code class=\"language-text\">c</code>, which are not the start of the characters we are looking for. So we can safely skip the <code class=\"language-text\">b</code> and <code class=\"language-text\">c</code>, and start fresh at <code class=\"language-text\">currentIndex+m</code>.</p>\n<p>Therefore, what’s important is how many characters you can safely skip. But exactly how many characters can you skip?</p>\n<h1 id=\"longest-proper-prefix-which-is-suffix-lps\" style=\"position:relative;\">Longest Proper Prefix which is Suffix (LPS)<a href=\"#longest-proper-prefix-which-is-suffix-lps\" aria-label=\"longest proper prefix which is suffix lps permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>To precisely find how many characters can be safely skipped, we need to find the longest proper prefix which is also a suffix. It <em>does sound weird</em>, but it is what it exactly reads.</p>\n<ul>\n<li>A proper prefix is any prefix of a word that is not the word itself.</li>\n<li>A suffix is any suffix of a word that is also the word itself.</li>\n</ul>\n<p>Let’s take the word <code class=\"language-text\">MOM</code> for example:</p>\n<ul>\n<li>Proper prefixes: <code class=\"language-text\">&#39;&#39;</code>, <code class=\"language-text\">&#39;M&#39;</code>, <code class=\"language-text\">&#39;MO&#39;</code></li>\n<li>Suffixes: <code class=\"language-text\">&#39;&#39;</code>, <code class=\"language-text\">&#39;M&#39;</code>, <code class=\"language-text\">&#39;OM&#39;</code>, <code class=\"language-text\">&#39;MOM&#39;</code></li>\n</ul>\n<p>Then, we can see that the LPS is <code class=\"language-text\">M</code>.</p>\n<p>The algorithm to find LPS is pretty simple. First, we will make an array (also called an auxiliary array) for storing the length of LPS in each unique prefix, like so:</p>\n<p>Given a string <code class=\"language-text\">ACABACACD</code>,</p>\n<ol>\n<li>check <code class=\"language-text\">A</code> is no LPS at all. record 0</li>\n<li>check <code class=\"language-text\">AC</code> has no LPS at all. record 0</li>\n<li>check <code class=\"language-text\">ACA</code> has an LPS of length 1 which is <code class=\"language-text\">A</code>. record <code class=\"language-text\">1</code></li>\n<li>check <code class=\"language-text\">ACAB</code> has no LPS at all. record 0</li>\n<li>check <code class=\"language-text\">ACABA</code> has an LPS of length 1 which is <code class=\"language-text\">A</code>. record <code class=\"language-text\">1</code></li>\n<li>check <code class=\"language-text\">ACABAC</code> has an LPS of length 2 which is <code class=\"language-text\">AC</code>. record <code class=\"language-text\">2</code></li>\n<li>check <code class=\"language-text\">ACABACA</code> has an LPS of length 3 which is <code class=\"language-text\">ACA</code>. record <code class=\"language-text\">3</code></li>\n<li>check <code class=\"language-text\">ACABACAC</code> has an LPS of length 2 which is <code class=\"language-text\">AC</code>, record <code class=\"language-text\">2</code></li>\n<li>check <code class=\"language-text\">ACABACACD</code> has no LPS at all. record 0</li>\n</ol>\n<p>The resulting LPS array should then be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 1, 0, 1, 2, 3, 2, 0]</code></pre></div>\n<h1 id=\"the-kmp-algorithm\" style=\"position:relative;\">The KMP algorithm<a href=\"#the-kmp-algorithm\" aria-label=\"the kmp algorithm permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>KMP is a string matching algorithm that runs in <code class=\"language-text\">O(n+m)</code> times, where</p>\n<ul>\n<li><code class=\"language-text\">n = length of the string to be matched</code></li>\n<li><code class=\"language-text\">m = length of the pattern to be matched</code></li>\n</ul>\n<p>This example runs with the following to elaborate the idea of KMP algorithm:</p>\n<ul>\n<li>text: <code class=\"language-text\">abcxabcdabxabcdabcdabcy</code></li>\n<li>pattern: <code class=\"language-text\">abcdabcy</code></li>\n</ul>\n<p>We realize that three characters (<code class=\"language-text\">abc</code>) match until we get to <code class=\"language-text\">text[3]</code> and <code class=\"language-text\">pattern[3]</code>. </p>\n<p>The aim is to <em>not go back to the previous indices</em> when we find this mismatch. We only want to go forward.</p>\n<p>Then we would need to find the LPS inside the <code class=\"language-text\">pattern</code> string right before <code class=\"language-text\">pattern[3]</code>: trivially, we know that <code class=\"language-text\">abc</code> does not have LPS inside itself because all characters are unique. </p>\n<p>This means we can start our next comparison directly from <code class=\"language-text\">text[3]</code> and <code class=\"language-text\">pattern[3]</code>, which are <code class=\"language-text\">x</code> and <code class=\"language-text\">a</code>.</p>\n<p>We compare <code class=\"language-text\">x</code> and <code class=\"language-text\">a</code> and they’re not a match, so we move to the next character. Forward on, we can see that <code class=\"language-text\">text[4:10]</code>, which is <code class=\"language-text\">abcdab</code>, has a exact match with <code class=\"language-text\">pattern[:6]</code>. But it’s not an entire match because <code class=\"language-text\">text[10]</code> and <code class=\"language-text\">pattern[6]</code> don’t match, which are <code class=\"language-text\">x</code> and <code class=\"language-text\">c</code>.</p>\n<p>Then we look for the LPS again in the substring of the pattern that had a match: <code class=\"language-text\">text[4:10]</code>, which is <code class=\"language-text\">abcdab</code>. Easily we can find that <code class=\"language-text\">ab</code> is an LPS at <code class=\"language-text\">pattern[0:2]</code> and <code class=\"language-text\">pattern[4:6]</code>. Having such an LPS means that the characters before <code class=\"language-text\">text[10]</code>, which is <code class=\"language-text\">x</code>, must be <code class=\"language-text\">ab</code>, trivially. But what this also means is that because <code class=\"language-text\">ab</code> is also a prefix of <code class=\"language-text\">abcdab</code>, we can start our next search from <code class=\"language-text\">text[10]</code> (<code class=\"language-text\">x</code>) and <code class=\"language-text\">pattern[2]</code> (<code class=\"language-text\">c</code>).</p>\n<p>Why? The search always consists of trivial character-by-character match, and the aim is to skip the redundant searches. <code class=\"language-text\">abcdab</code> of <code class=\"language-text\">abcdabcy</code> has an LPS as <code class=\"language-text\">ab</code> and the text we were matching has <code class=\"language-text\">... abcdabx ...</code>. This means that by the time we get to <code class=\"language-text\">x</code>, we already know that we don’t have to go back to the beginning of the pattern to start the search over, because we have already matched <code class=\"language-text\">ab</code>. Therefore, the next search will start from <code class=\"language-text\">x</code> and <code class=\"language-text\">pattern[2]</code>, which is <code class=\"language-text\">c</code>.</p>\n<p>Again, comparing <code class=\"language-text\">c</code> and <code class=\"language-text\">x</code>. Check if <code class=\"language-text\">pattern[0:2]</code> has an LPS: no. Then we start character matching from <code class=\"language-text\">x</code> and <code class=\"language-text\">pattern[0]</code>, all fresh again.</p>\n<p>Next up, we see that <code class=\"language-text\">... xabcdabcdabcy ...</code> has a match of <code class=\"language-text\">abcdabc</code> with <code class=\"language-text\">pattern[:7]</code>, but it’s not an entire match, leaving <code class=\"language-text\">y</code> in the last index in the pattern unmatched with <code class=\"language-text\">d</code> (<code class=\"language-text\">text[18]</code>). Again, we see if there is an LPS in <code class=\"language-text\">abcdabc</code>. This time, the LPS is <code class=\"language-text\">abc</code>. <em>This means that the last three characters that were checked for match are also the three characters at the beginning of the match, so we can safely say that we already have matched the last three characters (<code class=\"language-text\">abc</code>) in <code class=\"language-text\">... xabcdabcdabc ...</code> with the three first characters of the pattern (<code class=\"language-text\">abc</code>).</em> So we can start pattern matching from the next character: <code class=\"language-text\">d</code> (<code class=\"language-text\">text[18]</code>) and <code class=\"language-text\">pattern[4]</code>, which is also <code class=\"language-text\">d</code>. </p>\n<p>Then finally we find the substring <code class=\"language-text\">abcdabcy</code> at the end of the text with trivial character-by-character comparison.</p>\n<h1 id=\"finding-the-lps-the-efficient-way\" style=\"position:relative;\">Finding the LPS: the efficient way<a href=\"#finding-the-lps-the-efficient-way\" aria-label=\"finding the lps the efficient way permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>We know how KMP algorithm works, but we didn’t discuss what an efficient way of obtaining an LPS would be when we looked at how to find an LPS. This is how it’s done:</p>\n<ol>\n<li>Create <code class=\"language-text\">int</code> variables <code class=\"language-text\">j</code> and <code class=\"language-text\">i</code> to track indices of an <code class=\"language-text\">lps_array</code> of length <code class=\"language-text\">len(word)</code></li>\n<li>Let <code class=\"language-text\">j</code> track the prefix, and let <code class=\"language-text\">i</code> track the suffix of each substring.</li>\n<li>Let <code class=\"language-text\">j</code> and <code class=\"language-text\">i</code> all start from index <code class=\"language-text\">0</code>. But because index <code class=\"language-text\">0</code> is always not an LPS, just start <code class=\"language-text\">i</code> from index 1.</li>\n<li>Check if <code class=\"language-text\">word[j] == word[i]</code>. If <code class=\"language-text\">true</code>, <code class=\"language-text\">lps_array[i] = j + 1</code> (which is <code class=\"language-text\">the length of matching suffix = the index of previously matching prefix + 1</code>) and increment <code class=\"language-text\">j</code> and <code class=\"language-text\">i</code> by <code class=\"language-text\">1</code>. Otherwise, increment <code class=\"language-text\">i</code> and reset <code class=\"language-text\">j</code> to <code class=\"language-text\">lps_array[j - 1]</code> (which is <code class=\"language-text\">the length of previously matching prefix</code>). Start this step again.</li>\n</ol>\n<p>This Youtube video just kills it, so I’ve watched it multiple times. I’ve set it to start from the LPS part.</p>\n<div class=\"gatsby-resp-iframe-wrapper\" style=\"padding-bottom: 56.25%; position: relative; height: 0; overflow: hidden; margin-bottom: 1.0725rem\" > <iframe src=\"https://www.youtube-nocookie.com/embed/GTJr8OvyEVQ?start=495\" title=\"YouTube video player\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen style=\" position: absolute; top: 0; left: 0; width: 100%; height: 100%; \"></iframe> </div>\n<p>an LPS can be constructed with the following code:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">func</span> <span class=\"token function\">createLpsArray</span><span class=\"token punctuation\">(</span>word <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    wordLen <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span>\n    lpsArray <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> wordLen<span class=\"token punctuation\">)</span>\n\n    i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n    j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;</span> wordLen <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n            lpsArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            j<span class=\"token operator\">++</span>\n            i<span class=\"token operator\">++</span>\n        <span class=\"token comment\">// has a prefix longer than 0 already, so check backwards again</span>\n        <span class=\"token comment\">// when there is a mismatch,</span>\n        <span class=\"token comment\">// we will check the index of previous</span>\n        <span class=\"token comment\">// possible prefix.</span>\n        <span class=\"token comment\">// this is possible because every element in the lps array</span>\n        <span class=\"token comment\">// represents the number of LPS in the substring from </span>\n        <span class=\"token comment\">// the beginning of the string to the index of the element.</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            j <span class=\"token operator\">=</span> lpsArray<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token comment\">// this means word[j] != word[i] &amp;&amp; j == 0</span>\n        <span class=\"token comment\">// there has been no prefix found so far for the current index i, </span>\n        <span class=\"token comment\">// so just move onto the next character to find the match</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> lpsArray\n<span class=\"token punctuation\">}</span></code></pre></div>\n<iframe frameborder=\"0\" width=\"100%\" height=\"800px\" src=\"https://replit.com/@9oelM/createLpsArray?lite=true\"></iframe>\n<p>The complexities, where <code class=\"language-text\">m</code> is the length of the word, are as follows:</p>\n<ul>\n<li>Time complexity: <code class=\"language-text\">O(m)</code>, because the for loop will run <code class=\"language-text\">2m</code> times at its worst and the constant <code class=\"language-text\">2</code> can be removed.</li>\n<li>Space complexity: <code class=\"language-text\">O(m)</code> because <code class=\"language-text\">lpsArray</code> is <code class=\"language-text\">[m]int</code>.</li>\n</ul>\n<h1 id=\"summing-everything-up-together-for-kmp-substring-search\" style=\"position:relative;\">Summing everything up together for KMP substring search<a href=\"#summing-everything-up-together-for-kmp-substring-search\" aria-label=\"summing everything up together for kmp substring search permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>Problem: given <code class=\"language-text\">a b x a b c a b c a b y</code> (spaces used for convenience), give all starting indices where substring(s) of the text contain the pattern <code class=\"language-text\">a b c a b y</code>.</p>\n<h2 id=\"get-the-lps-array\" style=\"position:relative;\">Get the LPS array<a href=\"#get-the-lps-array\" aria-label=\"get the lps array permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>For the pattern <code class=\"language-text\">a b c a b y</code>:</p>\n<ol>\n<li>\n<p><code class=\"language-text\">a</code> and <code class=\"language-text\">b</code> are not the same, so the array would be</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 0, 0, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">a</code> and <code class=\"language-text\">c</code> are not the same, so the array will still be</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 0, 0, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">a</code> and <code class=\"language-text\">a</code> are the same. Increment <code class=\"language-text\">i</code> and <code class=\"language-text\">j</code> together by one.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 1, 0, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">b</code> and <code class=\"language-text\">b</code> are the same. Because <code class=\"language-text\">lpsArray[i] = lpsArray[j] + 1</code>, <code class=\"language-text\">lpsArray[i] = 1 + 1 = 2</code>. Increment <code class=\"language-text\">i</code> and <code class=\"language-text\">j</code> together by one.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 1, 2, 0]</code></pre></div>\n</li>\n<li>\n<p><code class=\"language-text\">c</code> and <code class=\"language-text\">y</code> are not the same. Then, look backwards (<code class=\"language-text\">j = lpsArray[j - 1]</code>) to see if there is any other prefixes available. <code class=\"language-text\">j = lpsArray[j - 1] = 0</code>. Again, <code class=\"language-text\">word[0] = a</code> and <code class=\"language-text\">a != y</code>. Mark <code class=\"language-text\">0</code> for the last index:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">[0, 0, 0, 1, 2, 0]</code></pre></div>\n</li>\n</ol>\n<h2 id=\"perform-the-substring-search-using-the-kmp-algorithm\" style=\"position:relative;\">Perform the substring search using the KMP algorithm<a href=\"#perform-the-substring-search-using-the-kmp-algorithm\" aria-label=\"perform the substring search using the kmp algorithm permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>what we have so far:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a b x a b c a b c a b y\na b c a b y\n[0, 0, 0, 1, 2, 0]</code></pre></div>\n<ol>\n<li>index 0: <code class=\"language-text\">a</code> and <code class=\"language-text\">a</code> are the same, so proceed together</li>\n<li>index 1: <code class=\"language-text\">b</code> and <code class=\"language-text\">b</code> are the same, so proceed together</li>\n<li>index 2: <code class=\"language-text\">x</code> and <code class=\"language-text\">c</code> are not the same. <code class=\"language-text\">lpsArray[2 - 1] == 0</code>, so there is no prefix found previously. Start fresh again</li>\n<li>index 3: <code class=\"language-text\">a</code> and <code class=\"language-text\">a</code> are the same, so proceed together</li>\n<li>index 4: <code class=\"language-text\">b</code> and <code class=\"language-text\">b</code> are the same, so proceed together</li>\n<li>index 5: <code class=\"language-text\">c</code> and <code class=\"language-text\">c</code> are the same, so proceed together</li>\n<li>index 6: <code class=\"language-text\">a</code> and <code class=\"language-text\">a</code> are the same, so proceed together</li>\n<li>index 7: <code class=\"language-text\">b</code> and <code class=\"language-text\">b</code> are the same, so proceed together</li>\n<li>index 7: <code class=\"language-text\">c</code> and <code class=\"language-text\">y</code> are not the same. But <code class=\"language-text\">lpsArray[5 - 1] == 2</code>, so there is a previously found prefix, of which length is <code class=\"language-text\">2</code>. This means that we already have a match of length 2 right before <code class=\"language-text\">c</code> in the text being searched, which we can now safely ignore. Therefore, start the match from <code class=\"language-text\">lpsArray[2]</code>, which is <code class=\"language-text\">c</code> and <code class=\"language-text\">text[8]</code> which is also <code class=\"language-text\">c</code>.</li>\n<li>index 8+: just proceed and we find that the pattern is the substring at the end of the text</li>\n</ol>\n<p>This process can be written in code as follows:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token punctuation\">(</span>\n\t<span class=\"token string\">\"fmt\"</span>\n<span class=\"token punctuation\">)</span>\n\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">createLpsArray</span><span class=\"token punctuation\">(</span>word <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    wordLen <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span>\n    lpsArray <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> wordLen<span class=\"token punctuation\">)</span>\n\n    i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n    j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;</span> wordLen <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n            lpsArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            j<span class=\"token operator\">++</span>\n            i<span class=\"token operator\">++</span>\n        <span class=\"token comment\">// has a prefix longer than 0 already, so check backwards again</span>\n        <span class=\"token comment\">// when there is a mismatch,</span>\n        <span class=\"token comment\">// we will check the index of previous</span>\n        <span class=\"token comment\">// possible prefix.</span>\n        <span class=\"token comment\">// this is possible because every element in the lps array</span>\n        <span class=\"token comment\">// represents the number of LPS in the substring from </span>\n        <span class=\"token comment\">// the beginning of the string to the index of the element.</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            j <span class=\"token operator\">=</span> lpsArray<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token comment\">// this means word[j] != word[i] &amp;&amp; j == 0</span>\n        <span class=\"token comment\">// there has been no prefix found so far for the current index i, so just move onto the next</span>\n        <span class=\"token comment\">// character to find the match</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> lpsArray\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">kmp</span><span class=\"token punctuation\">(</span>text <span class=\"token builtin\">string</span><span class=\"token punctuation\">,</span> pattern <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    matchingIndices <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> <span class=\"token number\">0</span><span class=\"token punctuation\">)</span>\n    <span class=\"token comment\">// always false</span>\n    <span class=\"token keyword\">if</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span> <span class=\"token operator\">></span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> matchingIndices\n    <span class=\"token punctuation\">}</span>\n    \n    lpsArray <span class=\"token operator\">:=</span> <span class=\"token function\">createLpsArray</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span>\n\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>lpsArray<span class=\"token punctuation\">)</span>\n\n    i <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n    j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>text<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token comment\">// uncomment to debug</span>\n    <span class=\"token comment\">// fmt.Printf(\"i: %v, j: %v, text[i]: %v, pattern[j]: %v\\n\", i, j, string(text[i]), string(pattern[j]))</span>\n      <span class=\"token keyword\">if</span> text<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> pattern<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n        i<span class=\"token operator\">++</span>\n        j<span class=\"token operator\">++</span>\n        <span class=\"token keyword\">if</span> j <span class=\"token operator\">==</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>pattern<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token comment\">// store the index of the text where the pattern starts inside the text</span>\n          matchingIndices <span class=\"token operator\">=</span> <span class=\"token function\">append</span><span class=\"token punctuation\">(</span>matchingIndices<span class=\"token punctuation\">,</span> i <span class=\"token operator\">-</span> j<span class=\"token punctuation\">)</span>\n          j <span class=\"token operator\">=</span> lpsArray<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token punctuation\">}</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> text<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> pattern<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n        j <span class=\"token operator\">=</span> lpsArray<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n      <span class=\"token comment\">// same as text[i] != pattern[j] &amp;&amp; j == 0</span>\n      <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n        i<span class=\"token operator\">++</span>\n      <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n\n    <span class=\"token keyword\">return</span> matchingIndices\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  cases <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">\"abxabcabcaby\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abcaby\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">\"aaaaaaaaaaabbb\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span><span class=\"token string\">\"aaaaaccccccaccaaaaaccbbb\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"cc\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span><span class=\"token punctuation\">{</span><span class=\"token string\">\"aabxabcabczabybxabcabcabxaabxabcabcabybcabcabxabcabcabyabyaby\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abcaby\"</span><span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n\n  <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span><span class=\"token punctuation\">(</span>cases<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">kmp</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> c<span class=\"token punctuation\">[</span><span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<iframe width=\"100%\" height=\"800px\" src=\"https://replit.com/@9oelM/kmp?lite=true\"></iframe>\n<h2 id=\"complexities\" style=\"position:relative;\">Complexities<a href=\"#complexities\" aria-label=\"complexities permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>Given:</p>\n<ul>\n<li><code class=\"language-text\">n = length of the string to be matched</code></li>\n<li><code class=\"language-text\">m = length of the pattern to be matched</code></li>\n</ul>\n<p><strong>The time complexity</strong> to build the LPS array is <code class=\"language-text\">O(m)</code> as we’ve seen before, and that to find the substring from the text is <code class=\"language-text\">O(n)</code>. Therefore, adding them up together yields <strong><code class=\"language-text\">O(m + n)</code></strong>, which is the time complexity of the KMP substring search.</p>\n<p><strong>The space complexity</strong> for LPS array is <code class=\"language-text\">O(m)</code> because it stores length of an array equivalent to <code class=\"language-text\">m</code>. The KMP search alone has the space complexity of <code class=\"language-text\">O(1)</code> because it does not require any variables other than constants. Therefore, the space complexity is <code class=\"language-text\">O(1 + m)</code> which is <strong><code class=\"language-text\">O(m)</code></strong>.</p>\n<h1 id=\"back-to-the-original-problem-find-the-shortest-palindrome\" style=\"position:relative;\">Back to the original problem: find the shortest palindrome<a href=\"#back-to-the-original-problem-find-the-shortest-palindrome\" aria-label=\"back to the original problem find the shortest palindrome permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>So let’s revisit the problem again:</p>\n<blockquote>\n<p>You are given a string s. You can convert s to a palindrome by adding characters in front of it. Return the shortest palindrome you can find by performing this transformation.</p>\n</blockquote>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">Example 1:\n\nInput: s = &quot;aacecaaa&quot;\nOutput: &quot;aaacecaaa&quot;\nExample 2:\n\nInput: s = &quot;abcd&quot;\nOutput: &quot;dcbabcd&quot;\n\nConstraints:\n\n0 &lt;= s.length &lt;= 5 * 104\ns consists of lowercase English letters only.</code></pre></div>\n<p>But you revisit the problem description and ponder upon it once more. Do you think you can reword it to something relevant to LPS or KMP search while preserving the same goal?</p>\n<p>Yes! If you reword it this way:</p>\n<blockquote>\n<p>Find the longest palindrome substring that starts from index 0.</p>\n</blockquote>\n<p>Actually, we mentioned this already in a very similar term at the beginning of this post:</p>\n<blockquote>\n<p><strong>Find the longest palindrome substring from the beginning of the substring.</strong></p>\n</blockquote>\n<p>Yes. So let’s take the first example for explanation. <code class=\"language-text\">aacecaaa</code> has <code class=\"language-text\">aacecaa</code> as the longest palindrome substring starting from index 0, so we just need to reverse the rest of the string, which happens to be <code class=\"language-text\">a</code>, and prepend it to the string, yielding <code class=\"language-text\">aaacecaaa</code>.</p>\n<p>Now, we don’t have to use KMP algorithm to solve this problem efficiently, but we are going to use the LPS table. KMP algorithm itself isn’t really actually relevant to this problem. Only the LPS table is.</p>\n<p>What we really need to do is to build a string like:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">s + &quot;#&quot; + reverse(s)</code></pre></div>\n<p>and just run <code class=\"language-text\">createLpsArray()</code> function which we learned how to create with that string.</p>\n<h2 id=\"solving-aacecaaa\" style=\"position:relative;\">Solving <code class=\"language-text\">aacecaaa</code><a href=\"#solving-aacecaaa\" aria-label=\"solving aacecaaa permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<p>For example, for the string: <code class=\"language-text\">aacecaaa</code>,</p>\n<ol>\n<li>\n<p>do <code class=\"language-text\">s+some_unique_delimiter+reverse(s)</code>. <code class=\"language-text\">some_unique_delimiter</code> could be anything that is not in the set of chars specified to be available in the problem, because it will otherwise mix up the LPS table obviously. For this example, we are using a <code class=\"language-text\">#</code>: </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">aacecaaa#aaacecaa</code></pre></div>\n</li>\n<li>\n<p>create an LPS table on that string first:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a  a  c  e  c  a  a  a  #  a  a  a  c  e  c  a  a\n\n[0, 1, 0, 0, 0, 1, 2, 2, 0, 1, 2, 2, 3, 4, 5, 6, 7]</code></pre></div>\n</li>\n<li>at this step, we can then notice that the <code class=\"language-text\">aacecaaa</code> has the longest palindrome string of length 7 from index 0. In essence, <em><strong>the LPS table of the crafted string works as viewing the reflection of the original string, which helps to find the longest palindrome in an efficient way.</strong></em></li>\n<li>\n<p>we now know the longest palindrome string is 7 from the index 0. Therefore, the answer has to be:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reverse(s[7:]) + s</code></pre></div>\n<p>which is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">a + aacecaaa = aaacecaaa</code></pre></div>\n</li>\n</ol>\n<h2 id=\"solving-abcd-just-to-give-another-example-for-perfection\" style=\"position:relative;\">Solving <code class=\"language-text\">abcd</code> (just to give another example for perfection)<a href=\"#solving-abcd-just-to-give-another-example-for-perfection\" aria-label=\"solving abcd just to give another example for perfection permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h2>\n<ol>\n<li>\n<p>do <code class=\"language-text\">s+some_unique_delimiter+reverse(s)</code>. again: </p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">abcd#dcba</code></pre></div>\n</li>\n<li>\n<p>create an LPS table on that string first:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\"> a  b  c  d  #  d  c  b  a\n\n[0, 0, 0, 0, 0, 0, 0, 0, 1]</code></pre></div>\n</li>\n<li>\n<p>the longest palindromic string has the length of 1. Therefore, this will be the answer:</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">reverse(s[1:]) + s</code></pre></div>\n<p>which is</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">d c b a + b c d = dcbabcd</code></pre></div>\n</li>\n</ol>\n<h1 id=\"solution-code\" style=\"position:relative;\">Solution code<a href=\"#solution-code\" aria-label=\"solution code permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>Finally, the solution will look like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"go\"><pre class=\"language-go\"><code class=\"language-go\"><span class=\"token keyword\">package</span> main\n\n<span class=\"token keyword\">import</span> <span class=\"token string\">\"fmt\"</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">createLpsArray</span><span class=\"token punctuation\">(</span>word <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span> <span class=\"token punctuation\">{</span>\n    wordLen <span class=\"token operator\">:=</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>word<span class=\"token punctuation\">)</span>\n    lpsArray <span class=\"token operator\">:=</span> <span class=\"token function\">make</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">int</span><span class=\"token punctuation\">,</span> wordLen<span class=\"token punctuation\">)</span>\n\n    i <span class=\"token operator\">:=</span> <span class=\"token number\">1</span>\n    j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span>\n\n    <span class=\"token keyword\">for</span> i <span class=\"token operator\">&lt;</span> wordLen <span class=\"token punctuation\">{</span>\n        <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">==</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token punctuation\">{</span>\n            lpsArray<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> j <span class=\"token operator\">+</span> <span class=\"token number\">1</span>\n            j<span class=\"token operator\">++</span>\n            i<span class=\"token operator\">++</span>\n        <span class=\"token comment\">// has a prefix longer than 0 already, so check backwards again</span>\n        <span class=\"token comment\">// when there is a mismatch,</span>\n        <span class=\"token comment\">// we will check the index of previous</span>\n        <span class=\"token comment\">// possible prefix.</span>\n        <span class=\"token comment\">// this is possible because every element in the lps array</span>\n        <span class=\"token comment\">// represents the number of LPS in the substring from </span>\n        <span class=\"token comment\">// the beginning of the string to the index of the element.</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token keyword\">if</span> word<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">!=</span> word<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span> <span class=\"token operator\">&amp;&amp;</span> j <span class=\"token operator\">!=</span> <span class=\"token number\">0</span> <span class=\"token punctuation\">{</span>\n            j <span class=\"token operator\">=</span> lpsArray<span class=\"token punctuation\">[</span>j <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n        <span class=\"token comment\">// this means word[j] != word[i] &amp;&amp; j == 0</span>\n        <span class=\"token comment\">// there has been no prefix found so far for the current index i, so just move onto the next</span>\n        <span class=\"token comment\">// character to find the match</span>\n        <span class=\"token punctuation\">}</span> <span class=\"token keyword\">else</span> <span class=\"token punctuation\">{</span>\n            i<span class=\"token operator\">++</span>\n        <span class=\"token punctuation\">}</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> lpsArray\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>s <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n    r <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token function\">rune</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">for</span> i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">:=</span> <span class=\"token number\">0</span><span class=\"token punctuation\">,</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token operator\">-</span><span class=\"token number\">1</span><span class=\"token punctuation\">;</span> i <span class=\"token operator\">&lt;</span> <span class=\"token function\">len</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span><span class=\"token operator\">/</span><span class=\"token number\">2</span><span class=\"token punctuation\">;</span> i<span class=\"token punctuation\">,</span> j <span class=\"token operator\">=</span> i<span class=\"token operator\">+</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> j<span class=\"token operator\">-</span><span class=\"token number\">1</span> <span class=\"token punctuation\">{</span>\n        r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span> <span class=\"token operator\">=</span> r<span class=\"token punctuation\">[</span>j<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span> r<span class=\"token punctuation\">[</span>i<span class=\"token punctuation\">]</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> <span class=\"token function\">string</span><span class=\"token punctuation\">(</span>r<span class=\"token punctuation\">)</span>\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">shortestPalindrome</span><span class=\"token punctuation\">(</span>s <span class=\"token builtin\">string</span><span class=\"token punctuation\">)</span> <span class=\"token builtin\">string</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token comment\">// s + # + reverse(s)</span>\n  <span class=\"token comment\">//  a a c e c a a a # a a a c e c a a</span>\n  <span class=\"token comment\">// [0 1 0 0 0 1 2 2 0 1 2 2 3 4 5 6 7]</span>\n  reversed <span class=\"token operator\">:=</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">)</span>\n  lpsArray <span class=\"token operator\">:=</span> <span class=\"token function\">createLpsArray</span><span class=\"token punctuation\">(</span>s <span class=\"token operator\">+</span> <span class=\"token string\">\"#\"</span> <span class=\"token operator\">+</span> reversed<span class=\"token punctuation\">)</span>\n  fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span>lpsArray<span class=\"token punctuation\">)</span>\n  longestPalindromeLength <span class=\"token operator\">:=</span> lpsArray<span class=\"token punctuation\">[</span><span class=\"token function\">len</span><span class=\"token punctuation\">(</span>lpsArray<span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span>\n\n  <span class=\"token comment\">// a aacecaaa</span>\n  <span class=\"token keyword\">return</span> <span class=\"token function\">reverse</span><span class=\"token punctuation\">(</span>s<span class=\"token punctuation\">[</span>longestPalindromeLength<span class=\"token punctuation\">:</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">+</span> s\n<span class=\"token punctuation\">}</span>\n\n<span class=\"token keyword\">func</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  cases <span class=\"token operator\">:=</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token builtin\">string</span><span class=\"token punctuation\">{</span>\n    <span class=\"token string\">\"aacecaaa\"</span><span class=\"token punctuation\">,</span> <span class=\"token string\">\"abcd\"</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">}</span>\n  <span class=\"token keyword\">for</span> <span class=\"token boolean\">_</span><span class=\"token punctuation\">,</span> c <span class=\"token operator\">:=</span> <span class=\"token keyword\">range</span><span class=\"token punctuation\">(</span>cases<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    fmt<span class=\"token punctuation\">.</span><span class=\"token function\">Println</span><span class=\"token punctuation\">(</span><span class=\"token function\">shortestPalindrome</span><span class=\"token punctuation\">(</span>c<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<iframe frameborder=\"0\" width=\"100%\" height=\"800px\" src=\"https://replit.com/@9oelM/shortest-palindrome-with-lps?lite=true\"></iframe>\n<h1 id=\"more-substring-search-algorithms\" style=\"position:relative;\">More substring search algorithms<a href=\"#more-substring-search-algorithms\" aria-label=\"more substring search algorithms permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<p>This post is about KMP algorithm. But there are also other algorithms that can do substring search as efficiently. Check these out too:</p>\n<ul>\n<li><a href=\"https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm\">Boyer-Moore string-search</a></li>\n<li><a href=\"https://en.wikipedia.org/wiki/Rabin%E2%80%93Karp_algorithm\">Rabin-Karp substring search</a></li>\n</ul>\n<h1 id=\"references\" style=\"position:relative;\">References<a href=\"#references\" aria-label=\"references permalink\" class=\"anchor after\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a></h1>\n<ul>\n<li><a href=\"https://binary-baba.medium.com/string-matching-kmp-algorithm-27c182efa387\">https://binary-baba.medium.com/string-matching-kmp-algorithm-27c182efa387</a></li>\n<li><a href=\"https://towardsdatascience.com/pattern-search-with-the-knuth-morris-pratt-kmp-algorithm-8562407dba5b\">https://towardsdatascience.com/pattern-search-with-the-knuth-morris-pratt-kmp-algorithm-8562407dba5b</a></li>\n<li><a href=\"https://leetcode.com/problems/shortest-palindrome/solution/\">https://leetcode.com/problems/shortest-palindrome/solution/</a></li>\n<li><a href=\"https://youtu.be/GTJr8OvyEVQ\">https://youtu.be/GTJr8OvyEVQ</a></li>\n<li><a href=\"https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation\">https://leetcode.com/problems/shortest-palindrome/discuss/60113/Clean-KMP-solution-with-super-detailed-explanation</a></li>\n</ul>","frontmatter":{"title":"Find the shortest palindrome: review of the KMP(Knuth–Morris–Pratt) algorithm","date":"January 06, 2022"}}},"pageContext":{"slug":"/2022-01-06--find-the-shortest-palindrome-review-of-kmp(knuth-morris-pratt)-algorithm/","previous":{"fields":{"slug":"/2022-01-02--elasticpwn-how-to-find-and-collect-data-from-exposed-elasticsearch-and-kibana-instances/"},"frontmatter":{"title":"elasticpwn: how to collect and analyse data from exposed Elasticsearch and Kibana instances","tab":"post"}},"next":null}},"staticQueryHashes":["3128451518","426816048"]}