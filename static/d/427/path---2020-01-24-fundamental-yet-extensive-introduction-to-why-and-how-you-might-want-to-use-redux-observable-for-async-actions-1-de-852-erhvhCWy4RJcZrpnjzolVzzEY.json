{"data":{"site":{"siteMetadata":{"title":"Joel's dev blog","author":"Joel Mun","siteUrl":"https://9oelm.github.io"}},"markdownRemark":{"id":"48bd2e8d-9a74-5583-af50-fe0fd901f65e","excerpt":"Problem I was struggling at my company trying to write some tests for RxJS operations.\nMost of the network requests were managed by RxJS, and none of them were…","html":"<h1>Problem</h1>\n<p>I was struggling at my company trying to write some tests for RxJS operations.\nMost of the network requests were managed by RxJS, and none of them were covered by tests. I wanted to write tests, but just did not know how to.</p>\n<p>But I really just wanted to start from the basics - I mean, the really basics, including why, and how we might want to use <code class=\"language-text\">redux-observable</code>.</p>\n<h1>tl;dr</h1>\n<p>If you want to hop straight into the source code, <a href=\"https://github.com/9oelM/redux-observable\">here it is.</a></p>\n<h1>First things first</h1>\n<h2>What is reactive programming?</h2>\n<blockquote>\n<p><a href=\"https://gist.github.com/staltz/868e7e9bc2a7b8c1f754#reactive-programming-is-programming-with-asynchronous-data-streams\">Reactive programming is programming with asynchronous data streams.</a></p>\n</blockquote>\n<ul>\n<li>Typical events are async event streams, and want to observe over them</li>\n<li>You have useful functions to combine/create/filter those streams</li>\n</ul>\n<blockquote>\n<p>A <strong>stream</strong> is a sequence of ongoing events ordered in time. It can emit three different things: a value (of some type), an error, or a “completed” signal. </p>\n</blockquote>\n<blockquote>\n<p>We capture these emitted events only asynchronously, by <strong>defining a function that will execute when a value is emitted,</strong> another function when an error is emitted, and another function when ‘completed’ is emitted.</p>\n</blockquote>\n<p>So this is essentially going back to <a href=\"https://github.com/9oelM/frontend-interview#observer\">the observer design pattern</a>.</p>\n<h2>Why bother to use rxjs?</h2>\n<h3>Abstraction.</h3>\n<p>If you use RP, you don’t have to really worry about implementation details, because it gives you high level of abstraction layer. So you never have to bother with <code class=\"language-text\">Promise</code>s and <code class=\"language-text\">await</code> in javascript anymore. Just declaratively implement what you want to do, and that’s it.</p>\n<h3>Async works made easier</h3>\n<p>Nowadays async operations have become a common thing, beacuse you might need to handle UI interactions &#x26; tonnes of network requests. </p>\n<p>So there’s a good chance that it is going to be a good fit for heavily network based application (both for frontend and backend).</p>\n<h3>Lots of helper functions to simplify work declaratively</h3>\n<p>You have dedicated helper functions to implement what you want to do, which otherwise you might do in a very complex way. Even if this does not fully come to your mind right now, you are going to notice it as you go through this article.</p>\n<h2>Why bother to use it with Redux?</h2>\n<p>Now we have a brief understanding of advantages of using RxJS. Now, we want to handle actions in Redux, but not all actions are synchronous. </p>\n<p>For a simple example, I have wrote a simple application that fetches text from the server and shows it, like this:</p>\n<p><img src=\"/1-421fc0f32fd5495ee252e8946c8844b6.gif\" alt=\"simple application that fetches text from the server and shows it\"> </p>\n<blockquote>\n<p>I assumed that you have a prior knowledge of some Typescript and React fundamentals including hooks.</p>\n</blockquote>\n<p>This is the project structure (omitted unimportant ones):</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">src\n├── App.tsx\n├── DummyTextRequestButton\n│   └── DummyTextRequestButton.tsx\n├── DummyTextViewer\n│   └── DummyTextViewer.tsx\n├── redux\n│   ├── actions.ts\n│   ├── constants.ts\n│   ├── reducer.ts\n│   ├── store.ts\n│   └── types.ts</code></pre></div>\n<h3>Redux-related things first</h3>\n<p>In redux, as you know, we mainly have actions and reducers. I have created three types of actions:</p>\n<ol>\n<li><code class=\"language-text\">StartRequestText</code>: I will <code class=\"language-text\">dispatch</code> this right before <code class=\"language-text\">fetch</code>ing from the dummy text API.</li>\n<li><code class=\"language-text\">FinishRequestText</code>: I will <code class=\"language-text\">dispatch</code> this right after receiving the text.</li>\n<li><code class=\"language-text\">ErrorRequestText</code>: I will <code class=\"language-text\">dispatch</code> this as soon as I encounter an error in the process described above.</li>\n</ol>\n<p>The above actions are implemented like this in <code class=\"language-text\">actions.ts</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { Constants as C } from &#39;./constants&#39;;\nimport { Action } from &#39;redux&#39;;\n\nexport interface StartRequestTextAction extends Action&lt;C.START_REQUEST_TEXT&gt; {}\n\nexport const startRequestText: () =&gt; StartRequestTextAction = () =&gt; ({\n  type: C.START_REQUEST_TEXT,\n});\n\nexport interface FinishRequestTextAction extends Action&lt;typeof C.FINISH_REQUEST_TEXT&gt; {\n  text: string;\n}\n\nexport const finishRequestText: (text: string) =&gt; FinishRequestTextAction = (text) =&gt; ({\n  type: C.FINISH_REQUEST_TEXT,\n  text,\n});\n\nexport interface ErrorRequestTextAction extends Action&lt;typeof C.ERROR_REQUEST_TEXT&gt; {\n  errorMsg: string;\n}\n\nexport const errorRequestText: (errorMsg: string) =&gt; ErrorRequestTextAction = (errorMsg) =&gt; ({\n  type: C.ERROR_REQUEST_TEXT,\n  errorMsg,\n});</code></pre></div>\n<p>And I simply defined some action types in <code class=\"language-text\">constants.ts</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">export enum Constants {\n  START_REQUEST_TEXT = &#39;START_REQUEST_TEXT&#39;,\n  FINISH_REQUEST_TEXT = &#39;FINISH_REQUEST_TEXT&#39;,\n  ERROR_REQUEST_TEXT = &#39;ERROR_REQUEST_TEXT&#39;,\n}</code></pre></div>\n<p>Putting them into <code class=\"language-text\">reducer.ts</code> is not difficult at all.\nWe just have to update the state for each different action.\nYou can see that I’m updating <code class=\"language-text\">isLoading</code>, <code class=\"language-text\">text</code>, and <code class=\"language-text\">errorMsg</code> individually according to each <code class=\"language-text\">type</code> of an <code class=\"language-text\">action</code>:</p>\n<p><code class=\"language-text\">reducer.ts</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { Reducer, combineReducers } from &#39;redux&#39;;\n\nimport { SimpleTextState, AllActions } from &#39;./types&#39;;\nimport { Constants as C } from &#39;./constants&#39;;\nimport { RootState } from &#39;./types&#39;;\n\nexport const simpleTextReducer: Reducer&lt;SimpleTextState, AllActions&gt; =\n  (state = { isLoading: false }, action) =&gt; {\n    switch (action.type) {\n      case C.START_REQUEST_TEXT:\n        return {\n          ...state,\n          isLoading: true,\n        };\n      case C.FINISH_REQUEST_TEXT:\n        return {\n          ...state,\n          text: action.text,\n          isLoading: false,\n        };\n      case C.ERROR_REQUEST_TEXT:\n        return {\n          ...state,\n          errorMsg: action.errorMsg,\n          isLoading: false,\n        };\n      default:\n        return state;\n    }\n  }\n\nconst reducers: Reducer&lt;RootState&gt; = combineReducers&lt;RootState&gt;({\n  simpleText: simpleTextReducer,\n});\n\nexport default reducers;</code></pre></div>\n<p>Again, not so much in <code class=\"language-text\">store.ts</code>. Just combine reducers (although we just have one, which is not usual in production envrionments) and configure redux devtools extension, and create store.</p>\n<p><code class=\"language-text\">store.ts</code></p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { combineReducers, createStore, Action, Reducer } from &#39;redux&#39;;\nimport reducers from &#39;./reducer&#39;;\nimport { SimpleTextState, RootState } from &#39;./types&#39;;\nimport { Constants as C } from &#39;./constants&#39;;\n\nconst store = createStore&lt;State, AllActions, any, any&gt;(\n  reducers, (window as any).__REDUX_DEVTOOLS_EXTENSION__ &amp;&amp; (window as any).__REDUX_DEVTOOLS_EXTENSION__()\n);\n\nexport default store;</code></pre></div>\n<p>And I defined the types we need in <code class=\"language-text\">types.ts</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import * as actions from &quot;./actions&quot;;\nimport { ActionType } from &#39;typesafe-actions&#39;;\n\nexport type AllActions = ActionType&lt;typeof actions&gt;;\n\nexport interface RootState {\n  simpleText: SimpleTextState;\n}\n\nexport interface SimpleTextState {\n  text?: string;\n  errorMsg?: string;\n  isLoading: boolean;\n}</code></pre></div>\n<p><code class=\"language-text\">App.tsx</code>\nIn the parent component, we just want to show two things: the button and the text.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import React from &#39;react&#39;;\nimport { Provider } from &#39;react-redux&#39;;\n\nimport store from &#39;./redux/store&#39;;\nimport DummyTextRequestButton from &#39;./DummyTextRequestButton/DummyTextRequestButton&#39;;\nimport DummyTextViewer from &#39;./DummyTextViewer/DummyTextViewer&#39;;\n\nconst App: React.FC = () =&gt; {\n  return (\n    &lt;Provider store={store}&gt;\n      &lt;div className=&quot;App&quot;&gt;\n        &lt;DummyTextRequestButton /&gt;\n        &lt;DummyTextViewer /&gt;\n      &lt;/div&gt;\n    &lt;/Provider&gt;\n  );\n}\n\nexport default App;</code></pre></div>\n<p><code class=\"language-text\">DummyTextRequestButton.tsx</code></p>\n<p>In this component, we have the logic of dispatching all of the actions we have defined earlier.\nYou have to recognize that we want to port the logic in <code class=\"language-text\">handleClick</code> to <code class=\"language-text\">redux-observable</code> later, because right now it’s not reactive at all.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import React, { FC } from &#39;react&#39;;\nimport { Dispatch } from &#39;redux&#39;;\nimport { useDispatch } from &#39;react-redux&#39;;\nimport { startRequestText, errorRequestText, finishRequestText } from &#39;../redux/actions&#39;;\n\nconst DummyTextRequestButton: FC = () =&gt; {\n  const dispatch: Dispatch = useDispatch();\n\n  const REQUEST_URL: string = &#39;https://baconipsum.com/api/?type=meat?paras=200&#39;;\n\n  const handleClick = async () =&gt; {\n    dispatch(startRequestText());\n\n    const response: string | Error = await fetch(REQUEST_URL)\n      .then((resp: Response) =&gt; resp.text())\n      .catch((err: Error) =&gt; err);\n\n    (response instanceof Error) ?\n      dispatch(errorRequestText(response.message)) :\n      dispatch(finishRequestText(response));\n  }\n\n  return (\n    &lt;button \n      style={{ backgroundColor: &#39;grey&#39;, color: &#39;white&#39;, width: 150, height: 50 }}\n      onClick={handleClick}\n    &gt;\n      Click me to request dummy text\n    &lt;/button&gt;\n  )\n};\n\nexport default DummyTextRequestButton;</code></pre></div>\n<p><code class=\"language-text\">DummyTextViewer.tsx</code>\nThis component consumes the redux state. Shows error, text, or loading based on the state.</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import React, { FC, ReactNode } from &#39;react&#39;;\nimport { useSelector } from &#39;react-redux&#39;;\n\nimport { RootState } from &#39;../redux/types&#39;;\n\nconst DummyTextViewer: FC = () =&gt; {\n  const {\n    simpleText: {\n      text, errorMsg, isLoading,\n    }\n  }: RootState = useSelector((state: RootState) =&gt; state);\n\n  const textViewer: ReactNode = errorMsg !== undefined ?\n    &lt;p&gt;oops, there was an error&lt;/p&gt; : (\n      &lt;p&gt;{text}&lt;/p&gt;\n    );\n\n  const dummyTextViewer: ReactNode | null = isLoading ? \n    (&lt;p&gt;loading...&lt;/p&gt;) : textViewer;\n\n  return (\n    &lt;section&gt;\n      {dummyTextViewer}\n    &lt;/section&gt;\n  )\n}\n\nexport default DummyTextViewer;</code></pre></div>\n<h3>With RxJS and redux-observable?</h3>\n<p>First of all, we are going to introduce relevant modules to our project:</p>\n<div class=\"gatsby-highlight\" data-language=\"bash\"><pre class=\"language-bash\"><code class=\"language-bash\"><span class=\"token function\">npm</span> i --save redux-devtools-extension redux-observable rxjs</code></pre></div>\n<p>Then we want to get rid of somewhat complex logic inside <code class=\"language-text\">DummyTextRequestButton.tsx</code>:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import React, { FC } from &#39;react&#39;;\nimport { Dispatch } from &#39;redux&#39;;\nimport { useDispatch } from &#39;react-redux&#39;;\nimport { startRequestText } from &#39;../redux/actions&#39;;\n\nconst DummyTextRequestButton: FC = () =&gt; {\n  const dispatch: Dispatch = useDispatch();\n\n  /** Now we just want to trigger the first single action */\n  const handleClick = async () =&gt; {\n    dispatch(startRequestText());\n  }\n\n  return (\n    &lt;button \n      style={{ backgroundColor: &#39;grey&#39;, color: &#39;white&#39;, width: 150, height: 50 }}\n      onClick={handleClick}\n    &gt;\n      Click me to request dummy text\n    &lt;/button&gt;\n  )\n};\n\nexport default DummyTextRequestButton;</code></pre></div>\n<p>We can do it like above because we are going to port our logic to <code class=\"language-text\">redux-observable</code>.</p>\n<p>Then, we are going to create something called <code class=\"language-text\">epics.ts</code> inside <code class=\"language-text\">redux</code> folder:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { Epic, ofType, combineEpics } from &quot;redux-observable&quot;;\nimport { from, of } from &#39;rxjs&#39;;\nimport { catchError, mergeMap } from &#39;rxjs/operators&#39;;\nimport { fromFetch } from &#39;rxjs/fetch&#39;;\n\nimport { Constants as C } from &#39;./constants&#39;;\nimport { RootState, AllActions } from &quot;./types&quot;;\nimport * as actions from &quot;./actions&quot;;\n\nconst startRequestTextEpic: Epic&lt;AllActions, AllActions, RootState&gt; = (action$, _store) =&gt;\n  action$.pipe(\n    ofType(C.START_REQUEST_TEXT),\n    mergeMap(() =&gt; {\n      const REQUEST_URL: string = &#39;https://baconipsum.com/api/?type=meat?paras=200&#39;;\n\n      const sendRequest$ = fromFetch(REQUEST_URL);\n\n      return sendRequest$.pipe(\n        mergeMap(\n          (resp: Response) =&gt; {\n            return from(resp.text())\n              .pipe(\n                mergeMap((text: string) =&gt; of(actions.finishRequestText(text))),\n              );\n          }\n        ),\n        catchError((error: Error) =&gt; of(actions.errorRequestText(error.message)))\n      )\n    }),\n  );\n\nconst rootEpic: Epic&lt;AllActions, AllActions, RootState&gt; = combineEpics(\n  startRequestTextEpic,\n);\n\nexport default rootEpic;</code></pre></div>\n<p>I know, I know. Lots of things going on here, but let me explain one by one.</p>\n<blockquote>\n<p>An <strong>epic</strong> is really just something that listens to a redux action and outputs other actions accordingly.</p>\n</blockquote>\n<p>So how is that done in the code above? We can see that <code class=\"language-text\">startRequestTextEpic</code> is listening to an action of the type called <code class=\"language-text\">C.START_REQUEST_TEXT</code> only. So this code, won’t get executed it any other actions are dispatched from redux.</p>\n<p>Ok, forget about <code class=\"language-text\">mergeMap</code> for now and then let’s go on for now. We can see that we are using RxJS’s own <code class=\"language-text\">fetch</code> method called <code class=\"language-text\">fromFetch</code>, which essentially just makes <code class=\"language-text\">fetch</code> into an observable.</p>\n<p>Now you process the response from <code class=\"language-text\">fetch</code>, and the <code class=\"language-text\">text</code> inside the response would be a payload to <code class=\"language-text\">finishRequestText</code> action.</p>\n<p>Otherwise, if you have an error while <code class=\"language-text\">fetch</code>ing, the error is going to be caught and will dispatch <code class=\"language-text\">errorRequestText</code> action.</p>\n<p>In this way, we have successfully ported our implementation in <code class=\"language-text\">handleClick</code> to inside an epic, and all that’s left for we us to do is actually configure a few things in <code class=\"language-text\">store.ts</code> to be able to use <code class=\"language-text\">redux-observable</code> in our project:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { createStore, applyMiddleware } from &#39;redux&#39;;\nimport { createEpicMiddleware, Epic } from &#39;redux-observable&#39;;\nimport { composeWithDevTools } from &#39;redux-devtools-extension&#39;;\n\nimport reducers from &#39;./reducer&#39;;\nimport { RootState, AllActions } from &#39;./types&#39;;\nimport rootEpic from &#39;./epics&#39;;\n\nconst epicMiddleware = createEpicMiddleware();\n\nconst composeEnhancers = composeWithDevTools({\n  // Specify name here, actionsBlacklist, actionsCreators and other options if needed\n});\n\nconst initialRootState: RootState = { simpleText: { isLoading: false } };\n\nconst store = createStore&lt;RootState, AllActions, any, any&gt;(\n  reducers,\n  initialRootState,\n  composeEnhancers(\n    applyMiddleware(\n      epicMiddleware,\n    ),\n  )\n);\n\nepicMiddleware.run(rootEpic as Epic&lt;AllActions, AllActions, any&gt;);\n\nexport default store;</code></pre></div>\n<p>So, after adding <code class=\"language-text\">redux-observable</code>, now we have some benefits:</p>\n<ol>\n<li>Reactiveness. You can easily handle asynchronous actions and state updates in redux by reacting to actions being dispatched.</li>\n<li>Separation of concerns. Now you don’t have to care about what to do after <code class=\"language-text\">startRequestText</code> in <code class=\"language-text\">DummyTextButton</code>, because all of the logics have been ported to <code class=\"language-text\">startRequestTextEpic</code>.</li>\n<li>Great toolchains. Right now we have used just few functions from RxJS, but combination of many functions will make it easier to process your data streams.</li>\n</ol>\n<h3>Extending further by utilizing what RxJS has</h3>\n<p>Now we have one little problem: when a user clicks on the button many times in such a short time, the request is going to be sent more than one time, which might be kind of useless, as shown in this gif:</p>\n<p><img src=\"/2-f23377929cc31526a5b09dbe8a0a8414.gif\" alt=\"Requests are sent more than one time unintendedly\"></p>\n<p>I clicked on the button three times, but actually what you all need is just a single request. So here’s what you can do:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { Epic, ofType, combineEpics } from &quot;redux-observable&quot;;\nimport { from, of, timer } from &#39;rxjs&#39;;\nimport { catchError, mergeMap, debounce } from &#39;rxjs/operators&#39;;\nimport { fromFetch } from &#39;rxjs/fetch&#39;;\n\nimport { Constants as C } from &#39;./constants&#39;;\nimport { RootState, AllActions } from &quot;./types&quot;;\nimport * as actions from &quot;./actions&quot;;\n\nconst startRequestTextEpic: Epic&lt;AllActions, AllActions, RootState&gt; = (action$, _store) =&gt;\n  action$.pipe(\n    ofType(C.START_REQUEST_TEXT),\n    debounce(() =&gt; timer(1000)),\n    mergeMap(() =&gt; {\n      const REQUEST_URL: string = &#39;https://baconipsum.com/api/?type=meat?paras=200&#39;;\n\n      const sendRequest$ = fromFetch(REQUEST_URL);\n\n      return sendRequest$.pipe(\n        mergeMap(\n          (resp: Response) =&gt; {\n            return from(resp.text())\n              .pipe(\n                mergeMap((text: string) =&gt; of(actions.finishRequestText(text))),\n              );\n          }\n        ),\n        catchError((error: Error) =&gt; of(actions.errorRequestText(error.message)))\n      )\n    }),\n  );\n\nconst rootEpic: Epic&lt;AllActions, AllActions, RootState&gt; = combineEpics(\n  startRequestTextEpic,\n);\n\nexport default rootEpic;</code></pre></div>\n<p>We just added <code class=\"language-text\">debounce</code>, and it is going to filter out only one action of type <code class=\"language-text\">START_REQUEST_TEXT</code> for a second, which means even if you click on the button three times in a single second, the request is going to be sent only once, like in the gif below:</p>\n<p><img src=\"/3-bc920a1f20fc783e2677d4fdc3137422.gif\" alt=\"Requests are sent just one time\"></p>\n<p>Alternatively, what you would want better is actually <code class=\"language-text\">switchMap</code>; It would cancel any pending request and switch to the last one:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">ofType(C.START_REQUEST_TEXT),\n    switchMap(() =&gt; {\n      const REQUEST_URL: string = &#39;https://baconipsum.com/api/?type=meat?paras=200&#39;;</code></pre></div>\n<p><img src=\"/4-18611d4e6ff4780e0d043d7c0dde371e.gif\" alt=\"The pending requests are cancelled, and only the last one is not\"></p>\n<p>Now, let’s say that you would have another button to show some other text, like this:</p>\n<p><img src=\"/5-ec43e9315a2034e6e4ef9fd2784154e5.gif\" alt=\"You have another button to show some other text\"></p>\n<p>Because we now have an additional UI, we need to handle one special case (we are not going to cover other cases, although there are many): <strong>you click on request dummy text button, but you change your mind to see hi instead</strong>. Then you would need to <strong>cancel and finish</strong> your action. </p>\n<p>For the sake of simplicity, I’m not going to show the entire code but <code class=\"language-text\">epics.ts</code> to demontrate that (you can still look into <a href=\"https://github.com/9oelM/redux-observable/tree/master/redux-observable\">the entire codebase from the Github repository</a>):</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { Epic, ofType, combineEpics } from &quot;redux-observable&quot;;\nimport { from, of, race, Observable } from &#39;rxjs&#39;;\nimport { catchError, mergeMap, switchMap, filter, map, take, merge } from &#39;rxjs/operators&#39;;\nimport { fromFetch } from &#39;rxjs/fetch&#39;;\n\nimport { Constants as C } from &#39;./constants&#39;;\nimport { RootState, AllActions } from &quot;./types&quot;;\nimport * as A from &quot;./actions&quot;;\n\nconst startRequestTextEpic: Epic&lt;AllActions, AllActions, RootState&gt; = (action$, store$) =&gt;\n  action$.pipe(\n    ofType(C.START_REQUEST_TEXT),\n    switchMap(() =&gt; {\n      const REQUEST_URL: string = &#39;https://baconipsum.com/api/?type=meat?paras=1000&#39;;\n\n      const sendRequest$: Observable&lt;A.FinishRequestTextAction | A.ErrorRequestTextAction&gt; =\n        fromFetch(REQUEST_URL).pipe(\n          mergeMap(\n            (resp: Response) =&gt; \n              from(resp.text())\n                .pipe(\n                  mergeMap((text: string) =&gt; of(A.finishRequestText(text))),\n                )\n          ),\n          catchError((error: Error) =&gt; of(A.errorRequestText(error.message))),\n        )\n\n      const cancelRequest$: Observable&lt;A.FinishRequestTextAction&gt; = action$.pipe(\n        ofType(C.TOGGLE_HI_TEXT),\n        filter(() =&gt; store$.value.simpleText.isHiTextShown),\n        map(() =&gt; A.finishRequestText(&#39;&#39;)),\n        take(1),\n      );\n\n      return race(sendRequest$, cancelRequest$);\n    }),\n  );\n\nconst rootEpic: Epic&lt;AllActions, AllActions, RootState&gt; = combineEpics(\n  startRequestTextEpic,\n);\n\nexport default rootEpic;</code></pre></div>\n<p>We now have two major parts: <code class=\"language-text\">sendRequest$</code> and <code class=\"language-text\">cancelRequest$</code>. In <code class=\"language-text\">cancelRequest$</code> ovservable, we are going to force finish requesting text, because there is no need to request the text anymore if you have switched to see the <code class=\"language-text\">hi</code> text.</p>\n<p><code class=\"language-text\">race</code> would take the job of cancelling out any other ongoing action if the other action is finished. It’s just like <code class=\"language-text\">Promise.race</code> in javascript! So, let’s see this in gif:</p>\n<p><img src=\"/6-f96e8bed5d17d151d373b5fceb3fe471.gif\" alt=\"The network request will be cancelled if you switch to see the hi text\"></p>\n<h3>Checkpoint</h3>\n<p>Do you now get why you would use redux-observable? It equips you with a nice set of tools to perform side-effects after actions are dispatched in redux.\nOtherwise it should have been a great pain for you manage events like cancellation manually, in vanilla javascript.</p>\n<p>But hey, we are not done yet. Let’s finish it with a guide to how to test these epics.</p>\n<h2>Testing your epics</h2>\n<h3>Method 1: Test output actions based on input actions.</h3>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { ActionsObservable, StateObservable } from &#39;redux-observable&#39;;\nimport { of, Subject, Observable } from &#39;rxjs&#39;;\nimport { toArray } from &#39;rxjs/operators&#39;;\nimport * as rxjs from &#39;rxjs&#39;;\nimport * as FF from &#39;rxjs/fetch&#39;;\n\nimport { startRequestTextEpic } from &#39;./epics&#39;;\nimport { Constants as C } from &#39;./constants&#39;;\nimport { RootState, AllActions } from &#39;./types&#39;;\n\ndescribe(&#39;startRequestTextEpic&#39;, () =&gt; {\n  let initialState: RootState;\n\n  beforeEach(() =&gt; {\n    initialState = { simpleText: { isLoading: false, isHiTextShown: false } };\n  })\n\n  it(&#39;should dispatch finishRequestText if there is no error&#39;, async () =&gt; {\n    const fakeFetchResponse: string = &#39;test response, hi&#39;;\n\n    /**\n     * Surprisingly, jest supports mocking individual functions \n     * from modules like this in each different test\n     */\n    // @ts-ignore: this is valid. See https://github.com/facebook/jest/issues/936#issuecomment-214556122\n    rxjs.race = jest.fn((...observables: Array&lt;Observable&lt;AllActions&gt;&gt;) =&gt; observables[0]);\n    // @ts-ignore this is valid also\n    FF.fromFetch = jest.fn(() =&gt; of({ text: () =&gt; of(fakeFetchResponse) }));\n\n    const action$ = ActionsObservable.of({\n      type: C.START_REQUEST_TEXT,\n    }) as ActionsObservable&lt;AllActions&gt;;\n\n    const state$ = new StateObservable&lt;RootState&gt;(new Subject(), initialState);\n\n    const actualActions$: Observable&lt;AllActions&gt; = startRequestTextEpic(action$, state$, {});\n    const actualActionsArray: Array&lt;AllActions&gt; = await actualActions$.pipe(toArray());.toPromise();\n    \n    const expectedActionsArray: Array&lt;AllActions&gt; = [\n      {\n        type: C.FINISH_REQUEST_TEXT,\n        text: fakeFetchResponse,\n      }\n    ]\n    expect(actualActionsArray).toEqual(expectedActionsArray);\n  });\n});</code></pre></div>\n<p>Whoa, lots of things to go through, right? But basically, all we are doing are just:</p>\n<ol>\n<li><strong>Mocking functions from certain modules to make them work according to our purpose</strong>. We are mocking <code class=\"language-text\">rxjs.race</code> and <code class=\"language-text\">FF.fromFetch</code> because, for <code class=\"language-text\">race</code>, we don’t want race won’t work well in a test environment and we can decide on which observable to emit, instead of depending on the code itself, and for <code class=\"language-text\">fromFetch</code>, we don’t want to use real <code class=\"language-text\">fetch</code> because it is going to take more time for no useful reason.</li>\n<li><strong>Running the epic with initial action and state</strong>. The epic will run, and spit out another set of actions as a result.</li>\n<li><strong>Testing the equality of the output actions with the expected</strong>. We just need to test if the epic gives expected set of actions.</li>\n</ol>\n<p>That’s pretty much it! But we need to test more, so why not simplify this process with a simple function?:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { Action } from &#39;redux&#39;;\nimport { Epic } from &#39;redux-observable&#39;;\nimport { ActionsObservable, StateObservable } from &#39;redux-observable&#39;;\nimport { Subject, Observable } from &#39;rxjs&#39;;\nimport { toArray } from &#39;rxjs/operators&#39;;\nimport { AllActions } from &#39;./types&#39;;\n\ninterface RunEpicTestParams&lt;ActionsUsed extends Action&lt;any&gt;, RootState&gt; {\n  epicToTest: Epic&lt;ActionsUsed, ActionsUsed, RootState&gt;;\n  inputActions: Array&lt;ActionsUsed&gt;;\n  initialState: RootState;\n  expectedActions: Array&lt;ActionsUsed&gt;;\n  done(): void;\n}\n\nexport async function runEpicTest&lt;ActionsUsed extends Action, State&gt;({\n  epicToTest,\n  inputActions,\n  initialState,\n  expectedActions,\n  done,\n}: RunEpicTestParams&lt;AllActions, State&gt;): Promise&lt;void&gt; {\n  const inputAction$ = ActionsObservable.of(...inputActions) as ActionsObservable&lt;ActionsUsed&gt;;\n  const state$ = new StateObservable&lt;State&gt;(new Subject(), initialState);\n\n  const actualActions$: Observable&lt;ActionsUsed&gt; = epicToTest(inputAction$, state$, {}) as Observable&lt;ActionsUsed&gt;;\n  const actualActionsArray: Array&lt;AllActions&gt; = await actualActions$.pipe(toArray()).toPromise();\n  \n  expect(actualActionsArray).toEqual(expectedActions);\n  done();\n}</code></pre></div>\n<p>Now, we can turn out test into:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">describe(&#39;startRequestTextEpic&#39;, () =&gt; {\n  let initialState: RootState;\n  let inputActions: Array&lt;AllActions&gt;;\n\n  beforeEach(() =&gt; {\n    initialState = { simpleText: { isLoading: false, isHiTextShown: false } };\n    inputActions = [{ type: C.START_REQUEST_TEXT }];\n  })\n\n  it(&#39;should dispatch finishRequestText if there is no error&#39;, async (done) =&gt; {\n    const fakeFetchResponse: string = &#39;test response, hi&#39;;\n\n    /**\n     * Surprisingly, jest supports mocking individual functions \n     * from modules like this in each different test\n     */\n    // @ts-ignore: this is valid. See https://github.com/facebook/jest/issues/936#issuecomment-214556122\n    rxjs.race = jest.fn((...observables: Array&lt;Observable&lt;AllActions&gt;&gt;) =&gt; observables[0]);\n    // @ts-ignore this is valid also\n    FF.fromFetch = jest.fn(() =&gt; of({ text: () =&gt; of(fakeFetchResponse) }));\n    runEpicTest&lt;AllActions, RootState&gt;({\n      epicToTest: startRequestTextEpic,\n      expectedActions: [\n        {\n          type: C.FINISH_REQUEST_TEXT,\n          text: fakeFetchResponse,\n        }\n      ],\n      inputActions,\n      initialState,\n      done,\n    });\n  });\n});</code></pre></div>\n<p>Much less boilerplate, right?</p>\n<p>Now we can write out tests for other things as well, like this:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">describe(&#39;startRequestTextEpic&#39;, () =&gt; {\n  let initialState: RootState;\n  let inputActions: Array&lt;AllActions&gt;;\n\n  beforeEach(() =&gt; {\n    initialState = { simpleText: { isLoading: false, isHiTextShown: false } };\n    inputActions = [{ type: C.START_REQUEST_TEXT }];\n  })\n\n  it(&#39;should dispatch finishRequestText if there is no error&#39;, (done) =&gt; {\n    // Already covered above\n  });\n\n  it(&#39;should dispatch errorRequestText if there is an error while fetching data&#39;, (done) =&gt; {\n    const fakeErrorMessage: string = &#39;test error message, hi&#39;;\n    // @ts-ignore\n    FF.fromFetch = jest.fn(() =&gt; of({ text: () =&gt; { throw new Error(fakeErrorMessage)} }));\n    \n    runEpicTest&lt;AllActions, RootState&gt;({\n      epicToTest: startRequestTextEpic,\n      expectedActions: [\n        {\n          type: C.ERROR_REQUEST_TEXT,\n          errorMsg: fakeErrorMessage,\n        }\n      ],\n      inputActions,\n      initialState,\n      done,\n    });\n  });\n\n  it(&#39;should dispatch finishRequestText earlier if TOGGLE_HI_TEXT is called in the middle&#39;, (done) =&gt; {\n    initialState = { simpleText: { ...initialState.simpleText, isHiTextShown: true } };\n\n    // @ts-ignore\n    rxjs.race = jest.fn((...observables: Array&lt;Observable&lt;AllActions&gt;&gt;) =&gt; observables[1]);\n\n    runEpicTest&lt;AllActions, RootState&gt;({\n      epicToTest: startRequestTextEpic,\n      expectedActions: [\n        {\n          type: C.FINISH_REQUEST_TEXT,\n          text: &#39;&#39;,\n        }\n      ],\n      inputActions: [...inputActions, { type: C.TOGGLE_HI_TEXT }],\n      initialState,\n      done,\n    });\n  });\n});</code></pre></div>\n<p>Now you’ve got to see all of your tests pass: </p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/41932aa437b7d0d81dd007703e6a87f6/5d6f0/7.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 38.85793871866295%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABHElEQVQoz41Ry1LCQBBcIyGgovg8cKCs4qRICJCQzQsCsXyUVln+gP//F+3MbJaicoFDb2Ymsz3dO8r/HWH194j7PIQ7LdCZZbiKSzzkb+gtS/T1hmo51HN0HNpBhGud4jbd4iapiGyDu+xV4BF5Z54LoTtNCQlOJxoOoeWb2IJzris1puMphBovccJ4ieEQVB3bZgtnYmta+jh39ogVJ94swUW4wtmCUdRxIQ2sjJUahelugI3dOuYB7ECxipYfwwsyucjfLtmUeC/n5p1N36hx5K4lNP/pDc307twshJvcRpNMPnYpw+oLo/cf2ep5bXWw/pCcl9HXW1zStu07H8Sg/MSw+kYvWkuBCYWMbLaDVCwzsTw4K2gSNGr/C/nlT8KKC2wAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"All of your tests pass\"\n        title=\"\"\n        src=\"/static/41932aa437b7d0d81dd007703e6a87f6/40fad/7.png\"\n        srcset=\"/static/41932aa437b7d0d81dd007703e6a87f6/707e9/7.png 148w,\n/static/41932aa437b7d0d81dd007703e6a87f6/649e0/7.png 295w,\n/static/41932aa437b7d0d81dd007703e6a87f6/40fad/7.png 590w,\n/static/41932aa437b7d0d81dd007703e6a87f6/b3fef/7.png 885w,\n/static/41932aa437b7d0d81dd007703e6a87f6/301c0/7.png 1180w,\n/static/41932aa437b7d0d81dd007703e6a87f6/5d6f0/7.png 1436w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<h3>Method 2: Use marble testing</h3>\n<p>Previously, we’ve only used some basic methods to test epics. Using marble tests would allow you to focus more on <em>when</em> things happen.</p>\n<p>If you are not familiar with the marble diagrams, please refer to <a href=\"http://reactivex.io/documentation/observable.html\">ReactiveX’s explanation on marble diagrams</a>. Alternatively, there are many other good resources out on the web.</p>\n<p>For the marble syntax, refer to <a href=\"https://rxjs-dev.firebaseapp.com/guide/testing/marble-testing#marble-syntax\">rxjs API docs</a>.</p>\n<h4>Hot vs Cold observables</h4>\n<p>There was a great article on Medium that simplified the definition of hot and cold observables, <a href=\"https://medium.com/@bencabanes/marble-testing-observable-introduction-1f5ad39231c#f123\">so I excerpted the definitions from it</a>. (Or look at <a href=\"https://rxjs-dev.firebaseapp.com/guide/testing/marble-testing\">rxjs API doc</a>)</p>\n<p>cold: begins subscription when the test begins. </p>\n<blockquote>\n<p><code class=\"language-text\">cold(--a--b--|, { a: &#39;Hello&#39;, b: &#39;World&#39; })</code> → Emit ‘Hello’ at 30ms and ‘World’ at 60ms, complete at 90ms.</p>\n</blockquote>\n<p>hot: begins subscription at the point of caret.</p>\n<blockquote>\n<p><code class=\"language-text\">hot(--^--a--b--|, { a: &#39;Hello&#39;, b: &#39;World&#39; })</code> → Subscription begins at point of caret, then emit ‘Hello’ at 30ms and ‘World’ at 60ms, complete at 90ms.</p>\n</blockquote>\n<h4>Testing events in relation to time</h4>\n<p>What we couldn’t really answer using method 1 was something like ‘can actions be really be cancelled if there are multiple action inputs, because we are using <code class=\"language-text\">switchMap</code>?’</p>\n<p>Now because we have a control over time, this is totally possible. </p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">import { of, Observable } from &#39;rxjs&#39;;\nimport * as rxjs from &#39;rxjs&#39;;\nimport * as FF from &#39;rxjs/fetch&#39;;\nimport { TestScheduler } from &#39;rxjs/testing&#39;;\n\nimport { startRequestTextEpic } from &#39;./epics&#39;;\nimport { Constants as C } from &#39;./constants&#39;;\nimport { RootState, AllActions } from &#39;./types&#39;;\nimport { ActionsObservable, StateObservable } from &#39;redux-observable&#39;;\nimport { HotObservable } from &#39;rxjs/internal/testing/HotObservable&#39;;\nimport { StartRequestTextAction } from &#39;./actions&#39;;\nimport { delay } from &#39;rxjs/operators&#39;;\nimport { ColdObservable } from &#39;rxjs/internal/testing/ColdObservable&#39;;\n\n  let initialState: RootState;\n\n  beforeEach(() =&gt; {\n    initialState = { simpleText: { isLoading: false, isHiTextShown: false } };\n  })\n\n  it(&#39;should dispatch finishRequestText if there is no error&#39;, (done) =&gt; {\n      const fakeFetchResponse: string = &#39;fake response&#39;;\n      // @ts-ignore: this is valid. See https://github.com/facebook/jest/issues/936#issuecomment-214556122\n      rxjs.race = jest.fn((...observables: Array&lt;Observable&lt;AllActions&gt;&gt;) =&gt; observables[0]);\n      // @ts-ignore this is valid also\n      FF.fromFetch = jest.fn(() =&gt; of({ text: () =&gt; of(fakeFetchResponse).pipe(delay(1)) }));\n\n      const testScheduler = new TestScheduler((actual, expected) =&gt; {\n        // somehow assert the two objects are equal\n        // e.g. with chai `expect(actual).deep.equal(expected)`\n        expect(actual).toEqual(expected);\n        done();\n      });\n\n      // https://github.com/redux-observable/redux-observable/issues/620#issuecomment-466736543\n      testScheduler.run(({ hot, cold, expectObservable }) =&gt; {\n      const actionInput$: ColdObservable&lt;StartRequestTextAction&gt; = cold(&#39;1ms -a&#39;, {\n        a: { type: C.START_REQUEST_TEXT }\n      });\n      const action$: ActionsObservable&lt;AllActions&gt; = new ActionsObservable(actionInput$) as ActionsObservable&lt;AllActions&gt;;\n\n      const stateInput$: HotObservable&lt;RootState&gt; = hot(&#39;-a&#39;, {\n        a: initialState,\n      });\n      const state$ = new StateObservable(stateInput$, initialState);\n\n      const output$ = startRequestTextEpic(action$, state$, {});\n    \n      expectObservable(output$).toBe(&#39;1ms --a&#39;, {\n        a: {\n          type: C.FINISH_REQUEST_TEXT,\n          text: fakeFetchResponse,\n        }\n      });\n    });\n  });\n\n    ...</code></pre></div>\n<p>This one is really basic; We request text, and for the sake of the test, we delay the response from <code class=\"language-text\">fromFetch</code> by <code class=\"language-text\">1</code>ms. Then we run <code class=\"language-text\">START_REQUEST_TEXT</code>, and expect the output action to be <code class=\"language-text\">FINISH_REQUEST_TEXT</code> after another <code class=\"language-text\">1</code>ms elapses. Simple. Right?</p>\n<p>But what about some more complex test, like actions being cancelled because of <code class=\"language-text\">switchMap</code>?:</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\">  it(&#39;should dispatch only one finishRequestText despite many startRequestText&#39;, (done) =&gt; {\n    const fakeFetchResponse: string = &#39;fake response&#39;;\n    // @ts-ignore: this is valid. See https://github.com/facebook/jest/issues/936#issuecomment-214556122\n    rxjs.race = jest.fn((...observables: Array&lt;Observable&lt;AllActions&gt;&gt;) =&gt; observables[0]);\n    // @ts-ignore this is valid also\n    FF.fromFetch = jest.fn(() =&gt; of({ text: () =&gt; {\n      return of(fakeFetchResponse).pipe(\n        delay(5),\n      )\n    }}));\n    const testScheduler = new TestScheduler((actual, expected) =&gt; {\n      // somehow assert the two objects are equal\n      // e.g. with chai `expect(actual).deep.equal(expected)`\n      expect(actual).toStrictEqual(expected);\n      done();\n    });\n    //                                12345   67890\n    const inputMarble: string =  &#39;1ms -abc(d|)--------&#39;\n    //                                12345   67890\n    const outputMarble: string = &#39;1ms -----   ----(d|)&#39;\n                                                // ^ it is normal to have this parenthesis because \n                                                //   &#39;complete&#39; event and d are synchronous\n                                                //   this position is the 10th frame\n\n    // https://github.com/redux-observable/redux-observable/issues/620#issuecomment-466736543\n    testScheduler.run(({ hot, cold, expectObservable }) =&gt; {\n      const actionInput$: ColdObservable&lt;StartRequestTextAction&gt; = cold(inputMarble, {\n        a: { type: C.START_REQUEST_TEXT },\n        b: { type: C.START_REQUEST_TEXT },\n        c: { type: C.START_REQUEST_TEXT },\n        d: { type: C.START_REQUEST_TEXT },\n      });\n      const action$: ActionsObservable&lt;AllActions&gt; = new ActionsObservable(actionInput$) as ActionsObservable&lt;AllActions&gt;;\n\n      const stateInput$: HotObservable&lt;RootState&gt; = hot(&#39;-a&#39;, {\n        a: initialState,\n      });\n      const state$ = new StateObservable(stateInput$, initialState);\n\n      const output$ = startRequestTextEpic(action$, state$, {});\n      \n      expectObservable(output$).toBe(outputMarble, {\n        d: {\n          type: C.FINISH_REQUEST_TEXT,\n          text: fakeFetchResponse,\n        }\n      });\n    });\n  });</code></pre></div>\n<p>In the above code, we are faking <code class=\"language-text\">fromFetch</code> again, and this time it is going to get you a response after <code class=\"language-text\">5</code>ms.\nNow you decide to <code class=\"language-text\">START_REQUEST_TEXT</code> four times just in <code class=\"language-text\">4ms</code>, in a row, each for each <code class=\"language-text\">1ms</code>.</p>\n<p>Then what is supposed to happen is that all of <code class=\"language-text\">a</code>, <code class=\"language-text\">b</code>, <code class=\"language-text\">c</code> get cancelled, because they are cancelled by the actions dispatched right after them, at the time <code class=\"language-text\">fromFetch</code> has not returned a response yet.\nThis is what <code class=\"language-text\">switchMap</code> exactly does. It will cancel other observables and only emit the most decently projected observable, which is <code class=\"language-text\">d</code> (after <code class=\"language-text\">5ms</code>).</p>\n<p>So that’s basically it! Of course, we could again make an abstraction of this testing logic, just like we did for <code class=\"language-text\">runEpicTest</code>, but too bad - I’m too tired right now, so I will leave that work left for you. :)</p>\n<h1>Conclusion</h1>\n<p>So far, we’ve covered:</p>\n<ol>\n<li>why you might want to use <code class=\"language-text\">rxjs</code> and <code class=\"language-text\">redux-observable</code> (maybe you could suggest more reasons in the comments section)</li>\n<li>how you could replace <code class=\"language-text\">redux</code> based code into a <code class=\"language-text\">redux-observable</code> one</li>\n<li>extensibility (benefits) of using <code class=\"language-text\">redux-observable</code>, especially for a complex logic</li>\n<li>two methods of how you can test your <code class=\"language-text\">epic</code>s</li>\n</ol>\n<h2>Appendix</h2>\n<p>Just some last words for you.</p>\n<h3>Suspicion on ‘always a pass’</h3>\n<p>Sometimes, it’s hard to know if your test is really working or just being passed because jest finishes tests earlier than the time you want. <a href=\"https://jestjs.io/docs/en/asynchronous\">Make sure you use <code class=\"language-text\">done</code></a>, and if you are still not sure, try to break the test by changing something like <code class=\"language-text\">expect(...).toEqual(...)</code> to <code class=\"language-text\">expect(...).not.toEqual(...)</code>. Then you should see something like this:</p>\n<p>\n  <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/c83c82de1cd5fbac0ff66c857a02e2ef/204e3/8.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n  \n  <span\n    class=\"gatsby-resp-image-wrapper\"\n    style=\"position: relative; display: block;  max-width: 590px; margin-left: auto; margin-right: auto;\"\n  >\n    <span\n      class=\"gatsby-resp-image-background-image\"\n      style=\"padding-bottom: 115.7303370786517%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAXCAYAAAALHW+jAAAACXBIWXMAABYlAAAWJQFJUiTwAAADqElEQVQ4y5VVyZbbNhCkFoqLVms8nvGSOHZy8EikSAKERFKzj33LKQe//ED+/xM6VQ1xnu3nHHIoNdAEGo1GVSv4M7fyT1nL67KVcXUtUXmUF82jnHVPMnd3stjfywS+4MpJsPkBW+DTXhamkr++/ipf/34nQZof5NJey8v2UdbdZw1wfv1F1u2TBk/MtcTVUca7VsKilWHeyAjgnGMiLBqZGSer+iBBkOHnqpYBbI8h7XaPxQfd+C28r1Fw3egUNNg22NtKQGeKk6f2Rqb1rWbEMbMaYTOzmhSd2hAB++wYcKTZeT/nHAeaMhyxuZHI3EpY4or2ViaYT1DT3j/IWxlgXcCMaLNGMdx1J+Aw+oco7Dyv5QUe5+XOyBKW41cYT+GPs1rWOyuLzMhZbvDNyDyzas+xZn3yLeBLtlaCCzg/lqW8Kyr5HfaPqtSFCwSNsSDc1hosReAVfPPMH8Kgq9wHnGE8hW+S4dUHeH4tLuo0gV1vkC18E1wjLFnXO5TgAdd2EtcVrMX18Wh5hxJ0KMFRr8xHCa72eGVsjqpWZg6bLWhSdRKXjaTGSGItOOgktTUohCwQMLUGj+TntNPa4DG8nbtSghikPOtKWTVOlo2VtK7xYg4UsKCDAYFrtZyPUYrxjn7SzCnCwirBRzsebvjKuO6JAkoDhxcGuWf1PQ55kuXhASc/qKVvaZ2skc0SifRICqMiSO2dBAwSg3sJ6EEOpsrHG7U9yMnEHJWnKVQVlyS+88i8BCkEiiJgdlG+16uxniRnDP5Rvwzk4eXHLEKSvOz0oIQwHjpHQgEDMMte8L1mBxkO2f4c5C7x0+/fdg/SJ0I2CWXHgH1H2fwPPEfe+Dp8355+zMD9Z9b+GwNuvGOQe12OUacx6kTtDgESflQc1apeOWfXUe2ynkfd+5zABJKhhi92lfwC+VGKlxi/L0qVGiX4GnPK8U3hLfV+Bks/1746+eZAcInJWyy8BJfel5VqmvgAXdP3Ab6PwG+YX8DPBEJQhbqlvomIBCe5/ZXxk7E14arQ4xLzVa/lCnQAmZPaazmBtBJIj2LwLcuXwpeI1+Yro5vM6gb/IzdQA9het8BB5vsC2q6gkgKapRKgbeh7Ag1HFSRqKwXlRjlGldF5MEDKM1dBZgYoEQgfajaCUhvAKHfKSa9d6Joa57WpXeh4fNL1MHfaA7Rjj/m6vDJs5O4lPjzKwuFPq/38rGf+E65o3V7OD2hx0POiQiLIKj5pma3uX825kIDKdvUuAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n    >\n      <img\n        class=\"gatsby-resp-image-image\"\n        style=\"width: 100%; height: 100%; margin: 0; vertical-align: middle; position: absolute; top: 0; left: 0; box-shadow: inset 0px 0px 0px 400px white;\"\n        alt=\"Your tests start to fail\"\n        title=\"\"\n        src=\"/static/c83c82de1cd5fbac0ff66c857a02e2ef/40fad/8.png\"\n        srcset=\"/static/c83c82de1cd5fbac0ff66c857a02e2ef/707e9/8.png 148w,\n/static/c83c82de1cd5fbac0ff66c857a02e2ef/649e0/8.png 295w,\n/static/c83c82de1cd5fbac0ff66c857a02e2ef/40fad/8.png 590w,\n/static/c83c82de1cd5fbac0ff66c857a02e2ef/b3fef/8.png 885w,\n/static/c83c82de1cd5fbac0ff66c857a02e2ef/301c0/8.png 1180w,\n/static/c83c82de1cd5fbac0ff66c857a02e2ef/204e3/8.png 1424w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n      />\n    </span>\n  </span>\n  \n  </a>\n    </p>\n<p>if your tests are still being passed, then there’s a problem.</p>\n<h3>Shoudn’t I test how epic changes the state as well?</h3>\n<p>No. Because epic is supposed to test how set of actions gives another set of actions. </p>\n<p>You are going to test that in your tests for reducer, because reducer is actually where the action will change the state.</p>\n<p>What epic really does is just until dispatching actions. It’s related to the state because it uses the state, but it does not directly modify the state. That’s the role of the reducer.</p>\n<h3>Source code repository</h3>\n<ul>\n<li><a href=\"https://github.com/9oelM/redux-observable/tree/master/redux-only\">redux implementation</a></li>\n<li><a href=\"https://github.com/9oelM/redux-observable/tree/master/redux-observable\">redux-observable implementation and tests</a></li>\n</ul>","frontmatter":{"title":"Extensive introduction to why and how you might want to use and test redux-observable","date":"January 24, 2020"}}},"pageContext":{"slug":"/2020-01-24--Fundamental-yet-extensive-introduction-to-why-and-how-you-might-want-to-use-redux-observable-for-async-actions/","previous":{"fields":{"slug":"/2020-01-08--The-shortcuts-I-like/"},"frontmatter":{"title":"The shortcuts I like"}},"next":{"fields":{"slug":"/2020-05-14--NSD-bulbaek-review/"},"frontmatter":{"title":"[개발자도 리뷰 할 수 있다] 낙성대 문기사불백 리뷰"}}}}